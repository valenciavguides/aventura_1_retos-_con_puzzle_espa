<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>8. Plaza de la Virgen</title>
<style>
    body {
        font-family: "Book Antiqua", Palatino, serif;
        margin: 1em;
        background: #fff;
        color: #222;
        font-size: 16px; /* Asegura un tama√±o base para 'em' */
    }
    h2 { /* Este es el t√≠tulo visible en la p√°gina */
        margin-bottom: 0.8em;
    }
    h3 {
        margin-bottom: 0.2em;
        font-size: 1.5em; /* Aumenta a√∫n m√°s el tama√±o de la pregunta general */
        text-align: center; /* Centrar la pregunta por defecto */
    }
    #reto {
        border: 3px solid #ccc; /* Grosor de borde constante */
        border-radius: 8px;
        padding: 1em;
        margin-bottom: 1em;
        position: relative;
        min-height: 220px;
    }
    .respuesta {
        margin: 0.4em 0;
        font-size: 1.3em; /* Tama√±o de las opciones de respuesta */
        display: flex;
        align-items: center;
    }
    .respuesta input[type="radio"] {
        margin-right: 0.7em;
        transform: scale(1.3);
        cursor: pointer;
    }
    .respuesta input[type="checkbox"] {
        margin-right: 0.7em;
        transform: scale(1.3);
        cursor: pointer;
    }
    .respuesta input[type="text"] {
        flex-grow: 1;
        font-size: 1.3em; /* Tama√±o del input de texto para respuestas */
        padding: 0.3em 0.5em;
        border-radius: 4px;
        border: 1px solid #999;
    }
    /* Contenedor para los botones para que est√©n en la misma l√≠nea */
    #button-container {
        display: flex;
        flex-wrap: wrap; /* Permite que los botones salten de l√≠nea si no hay espacio */
        gap: 1em; /* Espacio entre los botones */
        margin-top: 1em;
        justify-content: center; /* Centra los botones horizontalmente */
        align-items: center; /* Alinea verticalmente los botones si tienen alturas diferentes */
    }

    button.btn, button#btnMostrarRespuesta, button#btnNextAfterReto {
        padding: 0.6em 1.2em;
        font-size: 1.1em;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background-color: #0077cc;
        color: white;
        user-select: none;
        transition: background-color 0.3s ease;
    }
    button.btn:hover, button#btnNextAfterReto:hover {
        background-color: #005699;
    }
    button.btn:disabled {
        background-color: #999;
        cursor: not-allowed;
    }
    #btnMostrarRespuesta {
        background-color: #28a745;
        display: none;
    }
    #btnMostrarRespuesta:hover {
        background-color: #1e7e34;
    }
    #btnNextAfterReto {
        background-color: #0077cc;
        display: none;
    }

    #respuestaCorrectaTexto {
        margin-top: 1em;
        font-weight: bold;
        text-align: center;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 1em;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        font-size: 1.5em;
        color: #222;
        z-index: 20;
        display: none;
        box-sizing: border-box;
    }
    #fuegos {
        pointer-events: none;
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        overflow: hidden;
        display: none;
    }

    /* Border colors for correct/incorrect */
    #reto.correct {
        border-color: #28a745;
    }
    #reto.incorrect {
        border-color: #c00;
    }

    /* Estilos espec√≠ficos para el iframe del puzzle */
    #puzzleIframe {
        width: 100%;
        height: calc(100vh - 150px);
        border: 1px solid #ddd;
        border-radius: 8px;
        display: block;
        margin: 1em auto;
    }

    /* Media Query para m√≥viles en horizontal: oculta el h2 y ajusta el espacio */
    @media (max-width: 800px) and (orientation: landscape) {
        h2 {
            display: none; /* Oculta el t√≠tulo "Reto Valencia be Guides" */
        }
        /* En landscape, las preguntas de retos normales tambi√©n pueden ajustarse */
        #reto:not(.puzzle-active) h3 {
             font-size: 1.2em; /* Puedes ajustar el tama√±o para landscape si es necesario */
        }
        /* Solo para el h3 del puzzle cuando est√° activo en landscape */
        #reto.puzzle-active h3 {
            display: none; /* Oculta la pregunta del reto de puzzle en landscape */
        }
        body {
            margin: 0.5em;
        }
        #reto {
            min-height: 180px;
            padding: 0.8em;
        }
        button.btn, button#btnMostrarRespuesta, button#btnNextAfterReto {
            font-size: 1em;
            padding: 0.5em 1em;
        }
        .respuesta {
            font-size: 1em;
        }
        .respuesta input[type="radio"], .respuesta input[type="checkbox"] {
            transform: scale(1.1);
        }
        #puzzleIframe {
            height: calc(100vh - 120px);
        }
    }

    /* Media Query para pantallas m√°s grandes o portrait */
    @media (min-width: 801px) or (orientation: portrait) {
        #puzzleIframe {
            max-width: 800px;
            height: 600px;
        }
        /* IMPORTANTE: Esta regla SOLO aplicar√° cuando el #reto contenga un iframe de puzzle */
        #reto.puzzle-active h3 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 0.3em;
            font-size: 1em; /* Mantiene el tama√±o peque√±o para las preguntas de los puzzles */
        }
    }
</style>
</head>
<body>

<div id="topBar">
  <div id="leftControls">
    <button id="restartBtn">üîÑ Reiniciar</button>
    <button id="pauseBtn">‚è∏Ô∏è Pausa</button>
    <span id="timer">03:00</span>
  </div>
</div>
<div id="puzzleWrapper">
  <canvas id="puzzleCanvas"></canvas>
  <div id="completeMsg">
    <strong id="messageText"></strong><br />
  </div>
</div>
<script>
const canvas = document.getElementById("puzzleCanvas");
const ctx = canvas.getContext("2d");
// URL de la imagen para el puzzle de la Plaza de la Virgen
const imageSrc = "imagenes_puzzles/P8_plaza_de_la_virgen.jpg";
const rows = 3, cols = 4;
let pieces = [], draggingPiece = null;
let offsetX = 0, offsetY = 0, placedCount = 0;
let img = new Image();
let animatingPiece = null, animFrame = 0, animDirection = 1, animScale = 1;
const completeMsg = document.getElementById("completeMsg");
const messageText = document.getElementById("messageText");
const restartBtn = document.getElementById("restartBtn");
const pauseBtn = document.getElementById("pauseBtn");
const timerDisplay = document.getElementById("timer");
const puzzleWrapper = document.getElementById("puzzleWrapper");
const placeSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
const failSound = new Audio("https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg");
const successSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
placeSound.volume = 0.3; failSound.volume = 0.4; successSound.volume = 0.5;
let paused = false, timeLeft = 180, timerInterval;
let puzzleEnded = false;

const effectCanvas = document.createElement("canvas");
const effectCtx = effectCanvas.getContext("2d");
effectCanvas.style.position = "absolute";
effectCanvas.style.top = "0";
effectCanvas.style.left = "0";
effectCanvas.style.pointerEvents = "none";
effectCanvas.style.width = "100%";
effectCanvas.style.height = "100%";
puzzleWrapper.appendChild(effectCanvas);

img.onload = () => { init(); };
img.src = imageSrc;

window.addEventListener("resize", resizePieces);
window.addEventListener("orientationchange", () => setTimeout(resizePieces, 300));

function resizePieces() {
  const w = puzzleWrapper.clientWidth;
  const h = puzzleWrapper.clientHeight;
  canvas.width = w;
  canvas.height = h;
  effectCanvas.width = w;
  effectCanvas.height = h;
  const pw = w / cols;
  const ph = h / rows;

  pieces.forEach(p => {
    const colIndex = Math.round(p.correctX / p.w);
    const rowIndex = Math.round(p.correctY / p.h);
    p.w = pw;
    p.h = ph;
    p.correctX = colIndex * pw;
    p.correctY = rowIndex * ph;
    if (p.placed) {
      p.x = p.correctX;
      p.y = p.correctY;
    } else {
      p.x = Math.min(p.x * (w / canvas.width), w - pw);
      p.y = Math.min(p.y * (h / canvas.height), h - ph);
    }
  });
  draw();
}

function init() {
  puzzleEnded = false;
  const w = puzzleWrapper.clientWidth, h = puzzleWrapper.clientHeight;
  canvas.width = w; canvas.height = h;
  effectCanvas.width = w; effectCanvas.height = h;
  const pw = w / cols, ph = h / rows;

  pieces = []; placedCount = 0;
  completeMsg.style.display = "none";
  puzzleWrapper.style.borderColor = "#333";

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      pieces.push({
        sx: c * img.width / cols, sy: r * img.height / rows,
        sw: img.width / cols, sh: img.height / rows,
        x: Math.random() * (w - pw), y: Math.random() * (h - ph),
        w: pw, h: ph, correctX: c * pw, correctY: r * ph,
        placed: false, scale: 1
      });
    }
  }

  timeLeft = 180; // Reiniciar tiempo
  updateTimerDisplay(); // Actualizar visualmente
  startTimer(); // Iniciar cuenta
  draw();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const p of pieces.filter(p => p.placed)) drawPiece(p);
  for (const p of pieces.filter(p => !p.placed)) drawPiece(p);
  if (animatingPiece) {
    animatingPiece.scale = animScale;
    animFrame++;
    animScale += 0.05 * animDirection;
    if (animFrame >= 10) animDirection = -1;
    if (animFrame >= 20) {
      animatingPiece.scale = 1;
      animatingPiece = null;
      animFrame = 0; animDirection = 1;
    }
  }
  requestAnimationFrame(draw);
}

function drawPiece(piece) {
  ctx.save();
  ctx.translate(piece.x + piece.w / 2, piece.y + piece.h / 2);
  ctx.scale(piece.scale, piece.scale);
  ctx.translate(-piece.w / 2, -piece.h / 2);
  ctx.drawImage(img, piece.sx, piece.sy, piece.sw, piece.sh, 0, 0, piece.w, piece.h);
  ctx.restore();
}

function onPointerDown(e) {
  if (puzzleEnded || paused) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  for (let i = pieces.length - 1; i >= 0; i--) {
    const p = pieces[i];
    if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
      draggingPiece = p;
      offsetX = x - p.x;
      offsetY = y - p.y;
      break;
    }
  }
  // A√±ade esto para prevenir el comportamiento por defecto (ej. selecci√≥n de texto)
  if (e.pointerType === "mouse" || e.pointerType === "touch") {
    e.preventDefault();
  }
}

function onPointerMove(e) {
  if (!draggingPiece || puzzleEnded || paused) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  draggingPiece.x = Math.min(Math.max(x - offsetX, 0), canvas.width - draggingPiece.w);
  draggingPiece.y = Math.min(Math.max(y - offsetY, 0), canvas.height - draggingPiece.h);
  // A√±ade esto para prevenir el comportamiento por defecto (ej. scroll)
  if (e.pointerType === "mouse" || e.pointerType === "touch") {
    e.preventDefault();
  }
}

function onPointerUp(e) {
  if (!draggingPiece || puzzleEnded || paused) return;
  if (Math.abs(draggingPiece.x - draggingPiece.correctX) < draggingPiece.w / 4 &&
      Math.abs(draggingPiece.y - draggingPiece.correctY) < draggingPiece.h / 4) {
    draggingPiece.x = draggingPiece.correctX;
    draggingPiece.y = draggingPiece.correctY;
    draggingPiece.placed = true;
    placedCount++;
    placeSound.play();
    animatingPiece = draggingPiece;
    animFrame = 0; animDirection = 1; animScale = 1;
  }
  // Eliminado: else { failSound.play(); } -> para quitar el sonido al colocar mal una pieza.
  draggingPiece = null;
  if (placedCount === pieces.length) {
    endPuzzle(true);
  }
}

function startTimer() {
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!paused && !puzzleEnded) {
      timeLeft--;
      updateTimerDisplay();
      if (timeLeft <= 0) {
        endPuzzle(false);
      }
    }
  }, 1000);
}

function updateTimerDisplay() {
  const m = Math.floor(timeLeft / 60);
  const s = timeLeft % 60;
  timerDisplay.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

function endPuzzle(success) {
  puzzleEnded = true;
  clearInterval(timerInterval);
  completeMsg.style.display = "block";

  if (success) {
    successSound.play();
    messageText.textContent = "üéâ ¬°Puzzle completado!";
    puzzleWrapper.style.borderColor = "green";
    runFireworks();
    // Env√≠a mensaje a la p√°gina padre indicando que el puzzle se complet√≥ con √©xito
    window.parent.postMessage("puzzle-state-completed", "*");
  } else {
    failSound.play();
    messageText.textContent = "‚è∞ Tiempo agotado. Gracias por participar.";
    puzzleWrapper.style.borderColor = "red";
    runConfetti();
    // Env√≠a mensaje a la p√°gina padre indicando que el tiempo del puzzle se agot√≥
    window.parent.postMessage("puzzle-state-timeout", "*");
  }
  // Siempre se env√≠a el mensaje para avanzar al siguiente reto, independientemente del resultado del puzzle
  window.parent.postMessage('advance-to-next', '*');
}

function runFireworks() {
  let duration = 5000;
  let startTime = null;
  const particles = [];
  const colors = ["#ff2e2e","#ff7f50","#ffcc00","#3cff5f","#1e90ff","#9b30ff"];

  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

  function createParticle(x, y) {
    return {
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 100,
      color: colors[Math.floor(Math.random() * colors.length)],
      size: Math.random() * 3 + 2
    };
  }

  function loop(timestamp) {
    if (!startTime) startTime = timestamp;
    let elapsed = timestamp - startTime;
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

    if (elapsed < duration) {
      if (particles.length < 100) {
        let x = Math.random() * effectCanvas.width;
        let y = Math.random() * effectCanvas.height / 2;
        for(let i=0; i<5; i++) {
          particles.push(createParticle(x, y));
        }
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
        else {
          effectCtx.beginPath();
          effectCtx.fillStyle = p.color;
          effectCtx.shadowColor = p.color;
          effectCtx.shadowBlur = 10;
          effectCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          effectCtx.fill();
          effectCtx.closePath();
        }
      }
      requestAnimationFrame(loop);
    } else {
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
  }
  requestAnimationFrame(loop);
}

function runConfetti() {
  let duration = 5000;
  let startTime = null;
  const confettiPieces = [];
  const colors = ["#ff0","#f0f","#0ff","#0f0","#00f","#f00"];

  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

  function createConfetti() {
    return {
      x: Math.random() * effectCanvas.width,
      y: Math.random() * -20,
      size: Math.random() * 8 + 8,
      speedY: Math.random() * 3 + 2,
      color: colors[Math.floor(Math.random() * colors.length)],
      tilt: Math.random() * 10 - 5,
      tiltSpeed: Math.random() * 0.1 + 0.05
    };
  }

  for(let i = 0; i < 150; i++) {
    confettiPieces.push(createConfetti());
  }

  function loop(timestamp) {
    if (!startTime) startTime = timestamp;
    let elapsed = timestamp - startTime;
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

    if (elapsed < duration) {
      confettiPieces.forEach(p => {
        p.y += p.speedY;
        p.tilt += p.tiltSpeed;
        if (p.y > effectCanvas.height) {
          p.x = Math.random() * effectCanvas.width;
          p.y = Math.random() * -20;
        }
        effectCtx.save();
        effectCtx.translate(p.x, p.y);
        effectCtx.rotate(p.tilt);
        effectCtx.fillStyle = p.color;
        effectCtx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
        effectCtx.restore();
      });
      requestAnimationFrame(loop);
    } else {
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
  }
  requestAnimationFrame(loop);
}

restartBtn.addEventListener("click", () => {
  paused = false;
  puzzleEnded = false;
  completeMsg.style.display = "none";
  puzzleWrapper.style.borderColor = "#333";
  init();
});
pauseBtn.addEventListener("click", () => {
  paused = !paused;
  pauseBtn.textContent = paused ? "‚ñ∂Ô∏è Continuar" : "‚è∏Ô∏è Pausa";
});

canvas.addEventListener("pointerdown", onPointerDown);
canvas.addEventListener("pointermove", onPointerMove);
canvas.addEventListener("pointerup", onPointerUp);
canvas.addEventListener("pointercancel", onPointerUp);
canvas.addEventListener("pointerout", onPointerUp);
canvas.addEventListener("pointerleave", onPointerUp);

</script>
</body>
</html>
