<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

<style>
Â  html, body {
Â  Â  margin: 0; padding: 0; height: 100%; /* Asegura que html y body ocupen toda la altura */
Â  Â  background: #f0f0f0;
Â  Â  font-family: sans-serif;
Â  Â  display: flex; flex-direction: column;
Â  Â  align-items: center; justify-content: flex-start;
Â  Â  overflow: hidden; /* Previene scroll general */
Â  }
Â  h1 {
Â  Â  font-size: 1.2em;
Â  Â  margin: 0;
Â  Â  padding: 5px 0;
Â  Â  text-align: center;
Â  Â  width: 99vw;
Â  Â  max-width: 1000px;
Â  }
Â  #topBar {
Â  Â  display: flex;
    flex-direction: column; /* Por defecto, apila los elementos (botÃ³n Siguiente y controles) */
Â  Â  align-items: center; /* Centra los elementos apilados horizontalmente */
Â  Â  margin-bottom: 0;
Â  Â  width: 99vw;
Â  Â  max-width: 1000px;
Â  Â  gap: 5px; /* Reduce el espacio entre elementos en la barra superior */
Â  Â  flex-wrap: nowrap;
Â  Â  padding: 5px 0;
Â  }
Â  #leftControls {
Â  Â  display: flex;
Â  Â  gap: 10px;
Â  Â  align-items: center;
Â  Â  flex-shrink: 1;
Â  Â  min-width: 0;
Â  Â  flex-grow: 1;
Â  Â  justify-content: flex-start; /* Alinea los botones de control a la izquierda dentro de su contenedor */
    width: 100%; /* Asegura que ocupe todo el ancho disponible en la columna */
    justify-content: center; /* Centra los controles en esta vista */
Â  }
Â  #restartBtn, #pauseBtn, #continueBtn {
Â  Â  padding: 6px 12px;
Â  Â  background: white;
Â  Â  color: black;
Â  Â  border: 2px solid black;
Â  Â  border-radius: 8px;
Â  Â  font-size: 0.9em;
Â  Â  cursor: pointer;
Â  Â  white-space: nowrap;
Â  }
Â  #timer {
Â  Â  font-size: 1em;
Â  Â  font-weight: bold;
Â  Â  min-width: 60px;
Â  Â  text-align: center;
Â  Â  white-space: nowrap;
Â  }
Â  #continueBtn {
Â  Â  display: none; /* Oculto por defecto, visible solo al finalizar */
    margin-bottom: 5px; /* Espacio entre el botÃ³n Siguiente y los controles */
Â  }
Â  #puzzleWrapper {
Â  Â  width: 99vw;
Â  Â  max-width: 1000px;
Â  Â  height: calc(100vh - 50px); /* Aumentado de 80px a 50px para mÃ¡s altura del puzzle */
Â  Â  background: #ddd;
Â  Â  position: relative;
Â  Â  border: 5px solid #333;
Â  Â  overflow: hidden;
Â  Â  touch-action: none;
Â  Â  flex-grow: 1;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  }
Â  canvas {
Â  Â  width: 100%; height: 100%; display: block;
Â  Â  user-select: none;
Â  }
Â  #completeMsg {
Â  Â  display: none;
Â  Â  position: absolute;
Â  Â  top: 40%; left: 50%;
Â  Â  transform: translate(-50%, -50%);
Â  Â  background: rgba(255,255,255,0.95);
Â  Â  padding: 20px;
Â  Â  border: 2px solid #333;
Â  Â  border-radius: 12px;
Â  Â  text-align: center;
Â  Â  z-index: 10;
Â  Â  font-size: 1.2em;
Â  }
Â  @media (orientation: landscape) {
Â  Â  h1 {
Â  Â  Â  display: none;
Â  Â  }
Â  Â  #topBar {
Â  Â  Â  flex-direction: row; /* En horizontal, vuelve a la disposiciÃ³n en fila */
Â  Â  Â  margin-bottom: 0;
Â  Â  Â  padding: 0;
Â  Â  Â  width: 100%;
Â  Â  Â  max-width: none;
Â  Â  Â  justify-content: center; /* Centra los controles */
Â  Â  }
    #leftControls {
        justify-content: center; /* Asegura el centrado en landscape */
    }
Â  Â  #puzzleWrapper {
Â  Â  Â  width: calc(100vw - 20px);
Â  Â  Â  height: calc(100vh - 40px); /* Mantiene un espacio mÃ­nimo para la barra superior */
Â  Â  Â  max-width: none;
Â  Â  }
Â  }
</style>
</head>
<body>

<h1></h1>
<div id="topBar">
Â  Â  <button id="continueBtn">Siguiente</button> Â  Â  <div id="leftControls">
Â  Â  Â  <button id="restartBtn">ğŸ”„ Reiniciar</button>
Â  Â  Â  <button id="pauseBtn">â¸ï¸ Pausa</button>
Â  Â  Â  <span id="timer">03:00</span>
Â  Â  </div>
</div>
<div id="puzzleWrapper">
Â  <canvas id="puzzleCanvas"></canvas>
Â  <div id="completeMsg">
Â  Â  <strong id="messageText"></strong><br />
Â  </div>
</div>
<script>
const canvas = document.getElementById("puzzleCanvas");
const ctx = canvas.getContext("2d");
// URL de la imagen para el puzzle de la Lonja de la Seda
const imageSrc = "imagenes_puzzles/P26_lonja.jpg";
const rows = 3, cols = 4;
let pieces = [], draggingPiece = null;
let offsetX = 0, offsetY = 0, placedCount = 0;
let img = new Image();
let animatingPiece = null, animFrame = 0, animDirection = 1, animScale = 1;
const completeMsg = document.getElementById("completeMsg");
const messageText = document.getElementById("messageText");
const restartBtn = document.getElementById("restartBtn");
const pauseBtn = document.getElementById("pauseBtn");
const timerDisplay = document.getElementById("timer");
const continueBtn = document.getElementById("continueBtn"); // Obtener referencia al botÃ³n "Siguiente"
const puzzleWrapper = document.getElementById("puzzleWrapper");
const placeSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
const failSound = new Audio("https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg");
const successSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
placeSound.volume = 0.3; failSound.volume = 0.4; successSound.volume = 0.5;
let paused = false, timeLeft = 180, timerInterval;
let puzzleEnded = false;

const effectCanvas = document.createElement("canvas");
const effectCtx = effectCanvas.getContext("2d");
effectCanvas.style.position = "absolute";
effectCanvas.style.top = "0";
effectCanvas.style.left = "0";
effectCanvas.style.pointerEvents = "none";
effectCanvas.style.width = "100%";
effectCanvas.style.height = "100%";
puzzleWrapper.appendChild(effectCanvas);

img.onload = () => { init(); };
img.src = imageSrc;

window.addEventListener("resize", () => {
Â  Â  // Retraso para asegurar que las dimensiones de puzzleWrapper se han actualizado
Â  Â  setTimeout(resizePieces, 100);
});
window.addEventListener("orientationchange", () => {
Â  Â  // Retraso para asegurar que las dimensiones de puzzleWrapper se han actualizado
Â  Â  setTimeout(resizePieces, 300);
});

function resizePieces() {
Â  const w = puzzleWrapper.clientWidth;
Â  const h = puzzleWrapper.clientHeight;

Â  canvas.width = w;
Â  canvas.height = h;
Â  effectCanvas.width = w;
Â  effectCanvas.height = h;

Â  const pw = w / cols;
Â  const ph = h / rows;

Â  pieces.forEach(p => {
Â  Â  // Calculamos la posiciÃ³n correcta basada en el nuevo tamaÃ±o del puzzleWrapper
Â  Â  const colIndex = Math.round(p.correctX / (p.w || 1)); // Evitar divisiÃ³n por cero
Â  Â  const rowIndex = Math.round(p.correctY / (p.h || 1));

Â  Â  p.w = pw;
Â  Â  p.h = ph;

Â  Â  p.correctX = colIndex * pw;
Â  Â  p.correctY = rowIndex * ph;

Â  Â  // Ajustar la posiciÃ³n de las piezas no colocadas para que no se salgan
Â  Â  if (!p.placed) {
Â  Â  Â  p.x = Math.min(Math.max(p.x, 0), w - pw);
Â  Â  Â  p.y = Math.min(Math.max(p.y, 0), h - ph);
Â  Â  } else {
Â  Â  Â  // Las piezas ya colocadas se reajustan a su nueva posiciÃ³n correcta
Â  Â  Â  p.x = p.correctX;
Â  Â  Â  p.y = p.correctY;
Â  Â  }
Â  });
Â  draw();
}

function init() {
Â  puzzleEnded = false;
Â  const w = puzzleWrapper.clientWidth, h = puzzleWrapper.clientHeight;
Â  canvas.width = w; canvas.height = h;
Â  effectCanvas.width = w; effectCanvas.height = h;
Â  const pw = w / cols, ph = h / rows;

Â  pieces = []; placedCount = 0;
Â  completeMsg.style.display = "none";
Â  puzzleWrapper.style.borderColor = "#333";
Â  continueBtn.style.display = 'none'; // Ocultar el botÃ³n al iniciar/reiniciar

Â  for (let r = 0; r < rows; r++) {
Â  Â  for (let c = 0; c < cols; c++) {
Â  Â  Â  pieces.push({
Â  Â  Â  Â  sx: c * img.width / cols, sy: r * img.height / rows,
Â  Â  Â  Â  sw: img.width / cols, sh: img.height / rows,
Â  Â  Â  Â  x: Math.random() * (w - pw), y: Math.random() * (h - ph),
Â  Â  Â  Â  w: pw, h: ph, correctX: c * pw, correctY: r * ph,
Â  Â  Â  Â  placed: false, scale: 1
Â  Â  Â  });
Â  Â  }
Â  }

Â  timeLeft = 180; // Reiniciar tiempo
Â  updateTimerDisplay(); // Actualizar visualmente
Â  startTimer(); // Iniciar cuenta
Â  draw();
}

function draw() {
Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  // Dibujar piezas colocadas primero, luego las no colocadas para que se vean por encima
Â  for (const p of pieces.filter(p => p.placed)) drawPiece(p);
Â  for (const p of pieces.filter(p => !p.placed)) drawPiece(p);

Â  if (animatingPiece) {
Â  Â  animatingPiece.scale = animScale;
Â  Â  animFrame++;
Â  Â  animScale += 0.05 * animDirection;
Â  Â  if (animFrame >= 10) animDirection = -1;
Â  Â  if (animFrame >= 20) {
Â  Â  Â  animatingPiece.scale = 1;
Â  Â  Â  animatingPiece = null;
Â  Â  Â  animFrame = 0; animDirection = 1;
Â  Â  }
Â  }
Â  requestAnimationFrame(draw);
}

function drawPiece(piece) {
Â  ctx.save();
Â  ctx.translate(piece.x + piece.w / 2, piece.y + piece.h / 2);
Â  ctx.scale(piece.scale, piece.scale);
Â  ctx.translate(-piece.w / 2, -piece.h / 2);
Â  ctx.drawImage(img, piece.sx, piece.sy, piece.sw, piece.sh, 0, 0, piece.w, piece.h);
Â  ctx.strokeStyle = '#333';
Â  ctx.lineWidth = 1; /* Bordes de igual grosor */
Â  ctx.strokeRect(0, 0, piece.w, piece.h);
Â  ctx.restore();
}

function onPointerDown(e) {
Â  if (puzzleEnded || paused) return;
Â  if (e.target === canvas) {
Â  Â  Â  e.preventDefault();
Â  }
Â  const rect = canvas.getBoundingClientRect();
Â  const x = e.clientX - rect.left;
Â  const y = e.clientY - rect.top;
Â  for (let i = pieces.length - 1; i >= 0; i--) {
Â  Â  const p = pieces[i];
Â  Â  if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
Â  Â  Â  draggingPiece = p;
Â  Â  Â  offsetX = x - p.x;
Â  Â  Â  offsetY = y - p.y;
Â  Â  Â  pieces.splice(i, 1); // Mueve la pieza al final para que se dibuje encima
Â  Â  Â  pieces.push(draggingPiece);
Â  Â  Â  break;
Â  Â  }
Â  }
}

function onPointerMove(e) {
Â  if (!draggingPiece || puzzleEnded || paused) return;
Â  e.preventDefault();
Â  const rect = canvas.getBoundingClientRect();
Â  const x = e.clientX - rect.left;
Â  const y = e.clientY - rect.top;
Â  draggingPiece.x = Math.min(Math.max(x - offsetX, 0), canvas.width - draggingPiece.w);
Â  draggingPiece.y = Math.min(Math.max(y - offsetY, 0), canvas.height - draggingPiece.h);
}

function onPointerUp(e) {
Â  if (!draggingPiece || puzzleEnded || paused) return;
Â  // Margen de tolerancia para colocar la pieza
Â  if (Math.abs(draggingPiece.x - draggingPiece.correctX) < draggingPiece.w / 4 &&
Â  Â  Â  Math.abs(draggingPiece.y - draggingPiece.correctY) < draggingPiece.h / 4) {
Â  Â  draggingPiece.x = draggingPiece.correctX;
Â  Â  draggingPiece.y = draggingPiece.correctY;
Â  Â  draggingPiece.placed = true;
Â  Â  placedCount++;
Â  Â  placeSound.play();
Â  Â  animatingPiece = draggingPiece; // Activar animaciÃ³n de pieza
Â  Â  animFrame = 0; animDirection = 1; animScale = 1;
Â  }
Â  draggingPiece = null;
Â  if (placedCount === pieces.length) {
Â  Â  endPuzzle(true);
Â  }
}

function startTimer() {
Â  clearInterval(timerInterval);
Â  timerInterval = setInterval(() => {
Â  Â  if (!paused && !puzzleEnded) {
Â  Â  Â  timeLeft--;
Â  Â  Â  updateTimerDisplay();
Â  Â  Â  if (timeLeft <= 0) {
Â  Â  Â  Â  endPuzzle(false);
Â  Â  Â  }
Â  Â  }
Â  }, 1000);
}

function updateTimerDisplay() {
Â  const m = Math.floor(timeLeft / 60);
Â  const s = timeLeft % 60;
Â  timerDisplay.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

function endPuzzle(success) {
Â  puzzleEnded = true;
Â  clearInterval(timerInterval);
Â  completeMsg.style.display = "block";
Â  continueBtn.style.display = 'inline-block'; // Mostrar el botÃ³n "Siguiente"

Â  if (success) {
Â  Â  successSound.play();
Â  Â  messageText.textContent = "ğŸ‰ Â¡Puzzle completado!";
Â  Â  puzzleWrapper.style.borderColor = "green";
Â  Â  runFireworks();
Â  Â  window.parent.postMessage("puzzle-state-completed", "*"); // Mensaje al padre
Â  } else {
Â  Â  failSound.play();
Â  Â  messageText.textContent = "â° Tiempo agotado. Gracias por participar.";
Â  Â  puzzleWrapper.style.borderColor = "red";
Â  Â  runConfetti();
Â  Â  window.parent.postMessage("puzzle-state-timeout", "*"); // Mensaje al padre
Â  }
Â  // Se elimina window.parent.postMessage('advance-to-next', '*'); de aquÃ­
Â  // Ahora se activa con el click del botÃ³n continueBtn
}

// Event Listener para el botÃ³n "Siguiente"
continueBtn.addEventListener('click', () => {
Â  Â  window.parent.postMessage('advance-to-next', '*');
});

function runFireworks() {
Â  let duration = 5000;
Â  let startTime = null;
Â  const particles = [];
Â  const colors = ["#ff2e2e","#ff7f50","#ffcc00","#3cff5f","#1e90ff","#9b30ff"];

Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

Â  function createParticle(x, y) {
Â  Â  return {
Â  Â  Â  x, y,
Â  Â  Â  vx: (Math.random() - 0.5) * 6,
Â  Â  Â  vy: (Math.random() - 0.5) * 6,
Â  Â  Â  life: 100,
Â  Â  Â  color: colors[Math.floor(Math.random() * colors.length)],
Â  Â  Â  size: Math.random() * 3 + 2
Â  Â  };
Â  }

Â  function loop(timestamp) {
Â  Â  if (!startTime) startTime = timestamp;
Â  Â  let elapsed = timestamp - startTime;
Â  Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

Â  Â  if (elapsed < duration) {
Â  Â  Â  if (particles.length < 100) {
Â  Â  Â  Â  let x = Math.random() * effectCanvas.width;
Â  Â  Â  Â  let y = Math.random() * effectCanvas.height / 2;
Â  Â  Â  Â  for(let i=0; i<5; i++) {
Â  Â  Â  Â  Â  particles.push(createParticle(x, y));
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  for (let i = particles.length - 1; i >= 0; i--) {
Â  Â  Â  Â  const p = particles[i];
Â  Â  Â  Â  p.x += p.vx;
Â  Â  Â  Â  p.y += p.vy;
Â  Â  Â  Â  p.vy += 0.1;
Â  Â  Â  Â  p.life--;
Â  Â  Â  Â  if (p.life <= 0) particles.splice(i, 1);
Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  effectCtx.beginPath();
Â  Â  Â  Â  Â  effectCtx.fillStyle = p.color;
Â  Â  Â  Â  Â  effectCtx.shadowColor = p.color;
Â  Â  Â  Â  Â  effectCtx.shadowBlur = 10;
Â  Â  Â  Â  Â  effectCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
Â  Â  Â  Â  Â  effectCtx.fill();
Â  Â  Â  Â  Â  effectCtx.closePath();
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  requestAnimationFrame(loop);
Â  Â  } else {
Â  Â  Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
Â  Â  }
Â  }
Â  requestAnimationFrame(loop);
}

function runConfetti() {
Â  let duration = 5000;
Â  let startTime = null;
Â  const confettiPieces = [];
Â  const colors = ["#ff0","#f0f","#0ff","#0f0","#00f","#f00"];

Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

Â  function createConfetti() {
Â  Â  return {
Â  Â  Â  x: Math.random() * effectCanvas.width,
Â  Â  Â  y: Math.random() * -20,
Â  Â  Â  size: Math.random() * 8 + 8,
Â  Â  Â  speedY: Math.random() * 3 + 2,
Â  Â  Â  color: colors[Math.floor(Math.random() * colors.length)],
Â  Â  Â  tilt: Math.random() * 10 - 5,
Â  Â  Â  tiltSpeed: Math.random() * 0.1 + 0.05
Â  Â  };
Â  }

Â  for(let i = 0; i < 150; i++) {
Â  Â  confettiPieces.push(createConfetti());
Â  }

Â  function loop(timestamp) {
Â  Â  if (!startTime) startTime = timestamp;
Â  Â  let elapsed = timestamp - startTime;
Â  Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

Â  Â  if (elapsed < duration) {
Â  Â  Â  confettiPieces.forEach(p => {
Â  Â  Â  Â  p.y += p.speedY;
Â  Â  Â  Â  p.tilt += p.tiltSpeed;
Â  Â  Â  Â  if (p.y > effectCanvas.height) {
Â  Â  Â  Â  Â  p.x = Math.random() * effectCanvas.width;
Â  Â  Â  Â  Â  p.y = Math.random() * -20;
Â  Â  Â  Â  }
Â  Â  Â  Â  effectCtx.save();
Â  Â  Â  Â  effectCtx.translate(p.x, p.y);
Â  Â  Â  Â  effectCtx.rotate(p.tilt);
Â  Â  Â  Â  effectCtx.fillStyle = p.color;
Â  Â  Â  Â  // Borde uniforme para las piezas de confeti
Â  Â  Â  Â  effectCtx.strokeStyle = '#333';
Â  Â  Â  Â  effectCtx.lineWidth = 1;
Â  Â  Â  Â  effectCtx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
Â  Â  Â  Â  effectCtx.strokeRect(-p.size/2, -p.size/4, p.size, p.size/2); // Dibujar el borde
Â  Â  Â  Â  effectCtx.restore();
Â  Â  Â  });
Â  Â  Â  requestAnimationFrame(loop);
Â  Â  } else {
Â  Â  Â  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
Â  Â  }
Â  }
Â  requestAnimationFrame(loop);
}

restartBtn.addEventListener("click", () => {
Â  paused = false;
Â  puzzleEnded = false;
Â  completeMsg.style.display = "none";
Â  puzzleWrapper.style.borderColor = "#333";
Â  init();
});
pauseBtn.addEventListener("click", () => {
Â  paused = !paused;
Â  pauseBtn.textContent = paused ? "â–¶ï¸ Continuar" : "â¸ï¸ Pausa";
});

// Event listeners para los eventos de puntero
canvas.addEventListener("pointerdown", onPointerDown);
canvas.addEventListener("pointermove", onPointerMove);
canvas.addEventListener("pointerup", onPointerUp);
canvas.addEventListener("pointercancel", onPointerUp);
canvas.addEventListener("pointerout", onPointerUp);
canvas.addEventListener("pointerleave", onPointerUp);

</script>
</body>
</html>
