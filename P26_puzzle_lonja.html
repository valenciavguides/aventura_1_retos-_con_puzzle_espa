<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle 26: Lonja de la Seda</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Press Start 2P', cursive;
            color: #ecf0f1;
            overflow: hidden;
        }
        .puzzle-container {
            text-align: center;
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #puzzleWrapper {
            position: relative;
            width: clamp(280px, 80vw, 800px);
            padding-bottom: 56.25%; /* Ratio 16:9 */
            height: 0;
            border: 5px solid #333;
            box-sizing: border-box;
            background-color: #222;
            margin-bottom: 20px;
            overflow: hidden;
            display: block;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        #puzzleCanvas {
            z-index: 1;
        }
        #effectCanvas {
            z-index: 2;
            pointer-events: none;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            background-color: #e67e22;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #d35400;
        }
        #timerDisplay {
            font-size: 1em;
            margin-top: 10px;
            background-color: #2c3e50;
            padding: 5px 10px;
            border-radius: 5px;
        }
        #completeMessage {
            font-size: 1.2em;
            color: gold;
            margin-top: 20px;
            display: none;
        }

        @media (max-width: 600px) {
            .puzzle-container {
                padding: 10px;
            }
            button {
                font-size: 0.6em;
                padding: 8px 10px;
            }
            #timerDisplay {
                font-size: 0.8em;
            }
            #completeMessage {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="puzzle-container">
        <h1>Puzzle: Lonja de la Seda</h1>
        <div id="puzzleWrapper">
            <canvas id="puzzleCanvas"></canvas>
            <canvas id="effectCanvas"></canvas>
        </div>
        <div class="controls">
            <button id="restartBtn">üîÑ Reiniciar</button>
            <button id="pauseBtn">‚è∏Ô∏è Pausar</button>
        </div>
        <div id="timerDisplay">Tiempo: 00:00</div>
        <div id="completeMessage">¬°Puzzle Completado! üéâ</div>
    </div>

   <script>
    const puzzleCanvas = document.getElementById('puzzleCanvas');
    const ctx = puzzleCanvas.getContext('2d');
    const effectCanvas = document.getElementById('effectCanvas');
    const effectCtx = effectCanvas.getContext('2d');
    
    const image = new Image();
    // *** CAMBIO 1: Ruta de la imagen con la barra inicial '/' ***
    const imageSrc = "/imagenes_puzzles/P26_lonja.jpg"; 

    // Variables globales que definen el estado del puzzle y sus elementos
    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const completeMsg = document.getElementById('completeMessage');
    const puzzleWrapper = document.getElementById('puzzleWrapper');
    const timerDisplay = document.getElementById('timerDisplay');
    let puzzlePieces = [];
    let cols = 4; // N√∫mero de columnas
    let rows = 3; // N√∫mero de filas
    let pieceWidth, pieceHeight;
    let currentPiece = null;
    let offsetX, offsetY;
    let startTime, timerInterval;
    let paused = false;
    let puzzleEnded = false; 

    // Esta funci√≥n se ejecuta cuando la imagen ha cargado completamente
    image.onload = () => {
        // Redimensiona los canvases ANTES de llamar a init()
        resizeCanvas(); 
        // Llama a init() SOLAMENTE cuando la imagen ha cargado y el canvas tiene su tama√±o final
        init(); 
    };
    image.onerror = () => {
        console.error("Error al cargar la imagen:", imageSrc);
        alert("No se pudo cargar la imagen del puzzle. Intenta recargar la p√°gina.");
    };
    // *** CAMBIO 2: Inicia la carga de la imagen DESPU√âS de definir 'onload' y 'onerror' ***
    image.src = imageSrc;

    function resizeCanvas() {
        const wrapperRect = puzzleWrapper.getBoundingClientRect();
        
        // Ajusta las dimensiones de ambos canvases al tama√±o del wrapper
        puzzleCanvas.width = wrapperRect.width;
        puzzleCanvas.height = wrapperRect.height;
        effectCanvas.width = wrapperRect.width;
        effectCanvas.height = wrapperRect.height;

        // Si las piezas ya han sido creadas (es decir, init ya se ha ejecutado antes),
        // recalcula su tama√±o y redibuja. Esto es √∫til para el redimensionamiento de la ventana.
        if (puzzlePieces.length > 0) {
            pieceWidth = puzzleCanvas.width / cols;
            pieceHeight = puzzleCanvas.height / rows;
            drawPuzzle(); 
        }
    }

    function init() {
        puzzleEnded = false;
        completeMsg.style.display = 'none';
        puzzleWrapper.style.borderColor = '#333';
        paused = false;
        pauseBtn.textContent = '‚è∏Ô∏è Pausar';
        timerDisplay.textContent = 'Tiempo: 00:00';
        clearInterval(timerInterval); // Limpia cualquier temporizador previo

        // *** CAMBIO 3: Recalcula pieceWidth y pieceHeight aqu√≠. ***
        // Esto es crucial porque init() se llama *despu√©s* de que resizeCanvas() haya configurado
        // el tama√±o del canvas en el 'image.onload'.
        pieceWidth = puzzleCanvas.width / cols;
        pieceHeight = puzzleCanvas.height / rows;

        createPieces(); // Crea las piezas con los tama√±os correctos
        shufflePieces(); // Mezcla las piezas
        drawPuzzle(); // Dibuja el puzzle mezclado
        
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000); // Inicia el temporizador
    }

    function createPieces() {
        puzzlePieces = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                puzzlePieces.push({
                    x: c * pieceWidth, // Posici√≥n inicial de la pieza (se mezclar√° despu√©s)
                    y: r * pieceHeight,
                    originalX: c * pieceWidth, // Posici√≥n correcta en el puzzle resuelto
                    originalY: r * pieceHeight,
                    width: pieceWidth,
                    height: pieceHeight,
                    row: r,
                    col: c,
                    originalRow: r,
                    originalCol: c,
                });
            }
        }
    }

    function shufflePieces() {
        // Algoritmo de mezcla de Fisher-Yates
        for (let i = puzzlePieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            // Intercambia posiciones (x,y) de las piezas
            [puzzlePieces[i].x, puzzlePieces[j].x] = [puzzlePieces[j].x, puzzlePieces[i].x];
            [puzzlePieces[i].y, puzzlePieces[j].y] = [puzzlePieces[j].y, puzzlePieces[i].y];
        }
    }

    function drawPuzzle() {
        // Limpia ambos canvases antes de redibujar
        ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        puzzlePieces.forEach(piece => {
            ctx.drawImage(
                image,
                // Coordenadas y dimensiones de la parte de la imagen a copiar
                piece.originalX * (image.naturalWidth / puzzleCanvas.width), 
                piece.originalY * (image.naturalHeight / puzzleCanvas.height), 
                piece.width * (image.naturalWidth / puzzleCanvas.width), 
                piece.height * (image.naturalHeight / puzzleCanvas.height), 
                // Coordenadas y dimensiones donde dibujar la pieza en el canvas
                piece.x, 
                piece.y, 
                piece.width, 
                piece.height 
            );
            // Dibuja el borde de la pieza (seg√∫n tu instrucci√≥n de "igual grosor")
            ctx.strokeStyle = '#555'; 
            ctx.lineWidth = 1; // El grosor del borde es constante
            ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
        });
    }

    function getPieceAt(x, y) {
        // Itera al rev√©s para encontrar la pieza superior (si hay solapamiento)
        for (let i = puzzlePieces.length - 1; i >= 0; i--) {
            const piece = puzzlePieces[i];
            if (x > piece.x && x < piece.x + piece.width &&
                y > piece.y && y < piece.y + piece.height) {
                return piece;
            }
        }
        return null;
    }

    function swapPieces(p1, p2) {
        // Intercambia las coordenadas de posici√≥n de las dos piezas
        [p1.x, p2.x] = [p2.x, p1.x];
        [p1.y, p2.y] = [p2.y, p1.y];
        drawPuzzle(); // Redibuja el puzzle despu√©s del intercambio
        if (checkWin()) {
            endPuzzle(); // Si se ha ganado, finaliza el puzzle
        }
    }

    function checkWin() {
        // Comprueba si todas las piezas est√°n en su posici√≥n original
        for (let i = 0; i < puzzlePieces.length; i++) {
            const piece = puzzlePieces[i];
            if (piece.x !== piece.originalX || piece.y !== piece.originalY) {
                return false; // Si alguna pieza no est√° en su lugar, no se ha ganado
            }
        }
        return true; // Todas las piezas est√°n en su lugar
    }

    function endPuzzle() {
        puzzleEnded = true;
        clearInterval(timerInterval); // Detiene el temporizador
        completeMsg.style.display = 'block'; // Muestra el mensaje de completado
        puzzleWrapper.style.borderColor = 'gold'; // Cambia el borde a dorado
        // *** Esta l√≠nea ya estaba, ¬°genial! Asegura la comunicaci√≥n con la p√°gina padre ***
        window.parent.postMessage('puzzle-completed', '*');
    }

    function updateTimer() {
        if (paused || puzzleEnded) return; // Si est√° pausado o terminado, no actualiza
        const currentTime = Date.now();
        const elapsedTime = Math.floor((currentTime - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        timerDisplay.textContent = `Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // Funciones de manejo de eventos para arrastrar y soltar con rat√≥n
    function handleMouseDown(e) {
        if (paused || puzzleEnded) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentPiece = getPieceAt(x, y); // Obtiene la pieza en la posici√≥n del clic
        if (currentPiece) {
            offsetX = x - currentPiece.x;
            offsetY = y - currentPiece.y;
            // Mueve la pieza actual al final del array para que se dibuje encima
            puzzlePieces = puzzlePieces.filter(p => p !== currentPiece);
            puzzlePieces.push(currentPiece);
            drawPuzzle(); // Redibuja con la pieza seleccionada encima
            effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        }
    }

    function handleMouseMove(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        currentPiece.x = x - offsetX; // Actualiza la posici√≥n de la pieza arrastrada
        currentPiece.y = y - offsetY;
        drawPuzzle(); // Redibuja el puzzle con la pieza en su nueva posici√≥n

        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        const targetPiece = getPieceAt(x, y); // Resalta la pieza sobre la que se arrastra
        if (targetPiece && targetPiece !== currentPiece) {
            effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            effectCtx.lineWidth = 3;
            effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.width, targetPiece.height);
        }
    }

    function handleMouseUp(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        const rect = puzzleCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const targetPiece = getPieceAt(mouseX, mouseY);

        if (targetPiece && targetPiece !== currentPiece) {
            swapPieces(currentPiece, targetPiece); // Si se solt√≥ sobre otra pieza, interc√°mbialas
        } 
        currentPiece = null; // Reinicia la pieza arrastrada
        drawPuzzle();
    }

    // Funciones de manejo de eventos para arrastrar y soltar con t√°ctil
    function handleTouchStart(e) {
        e.preventDefault(); // Previene el scroll por defecto
        const touch = e.touches[0];
        handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        handleMouseUp({}); // Simula un 'mouseup' al levantar el dedo
    }

    // Asignaci√≥n de eventos de rat√≥n
    puzzleCanvas.addEventListener('mousedown', handleMouseDown);
    puzzleCanvas.addEventListener('mousemove', handleMouseMove);
    puzzleCanvas.addEventListener('mouseup', handleMouseUp);
    puzzleCanvas.addEventListener('mouseleave', handleMouseUp); // Para cuando el rat√≥n sale del canvas

    // Asignaci√≥n de eventos t√°ctiles
    puzzleCanvas.addEventListener('touchstart', handleTouchStart);
    puzzleCanvas.addEventListener('touchmove', handleTouchMove);
    puzzleCanvas.addEventListener('touchend', handleTouchEnd);
    puzzleCanvas.addEventListener('touchcancel', handleTouchEnd); // Si la interacci√≥n t√°ctil se cancela

    // Eventos de botones
    restartBtn.addEventListener('click', init); // Reinicia el puzzle
    pauseBtn.addEventListener('click', () => {
        paused = !paused; // Cambia el estado de pausa
        if (paused) {
            pauseBtn.textContent = '‚ñ∂Ô∏è Reanudar'; // Cambia el texto del bot√≥n
            clearInterval(timerInterval); // Detiene el temporizador
        } else {
            pauseBtn.textContent = '‚è∏Ô∏è Pausar'; // Cambia el texto del bot√≥n
            // Reajusta el tiempo para que el temporizador no salte al reanudar
            const currentTime = Date.now();
            const currentElapsedTime = Math.floor((currentTime - startTime) / 1000);
            startTime = Date.now() - currentElapsedTime * 1000;
            timerInterval = setInterval(updateTimer, 1000); // Reanuda el temporizador
        }
    });

    // Escucha el evento de redimensionamiento de la ventana para ajustar el canvas
    window.addEventListener('resize', resizeCanvas);
    // *** CAMBIO 4: Llama a resizeCanvas() inicialmente aqu√≠, fuera del 'image.onload'. ***
    // Esto asegura que los canvases tengan un tama√±o v√°lido ANTES de que la imagen cargue,
    // previniendo que pieceWidth y pieceHeight se calculen como 0 al inicio.
    // La funci√≥n init() sigue siendo llamada en image.onload para asegurar que
    // el puzzle se crea solo cuando la imagen est√° lista.
    resizeCanvas(); 
</script>
</body>
</html>
