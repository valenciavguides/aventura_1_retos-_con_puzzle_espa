<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Puzzle 18: Plaza de Toros y Estaciรณn del Norte</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
<style>
ย html, body {
ย ย margin: 0; padding: 0; height: 100%;
ย ย background: #2c3e50;
ย ย font-family: 'Press Start 2P', cursive;
ย ย color: #ecf0f1;
ย ย display: flex; flex-direction: column;
ย ย align-items: center; justify-content: flex-start;
ย ย overflow: hidden;
ย }
ย h1 {
ย ย font-size: 1.2em;
ย ย margin: 8px;
ย ย text-align: center;
ย }
ย #topBar {
ย ย display: flex;
ย ย align-items: center;
ย ย justify-content: space-between;
ย ย margin-bottom: 10px;
ย ย width: 95vw;
ย ย max-width: 1000px;
ย ย gap: 10px;
ย ย flex-wrap: nowrap;
ย }
ย #leftControls {
ย ย display: flex;
ย ย gap: 10px;
ย ย align-items: center;
ย ย flex-shrink: 1;
ย ย min-width: 0;
ย }
ย #restartBtn, #pauseBtn, #continueBtn {
ย ย background-color: #e67e22;
ย ย color: white;
ย ย border: none;
ย ย padding: 10px 15px;
ย ย border-radius: 5px;
ย ย cursor: pointer;
ย ย font-family: 'Press Start 2P', cursive;
ย ย font-size: 0.7em;
ย ย transition: background-color 0.3s ease;
ย ย white-space: nowrap;
ย }
ย #restartBtn:hover, #pauseBtn:hover, #continueBtn:hover {
ย ย background-color: #d35400;
ย }
ย #timer {
ย ย font-size: 1em;
ย ย font-weight: bold;
ย ย min-width: 60px;
ย ย text-align: center;
ย ย white-space: nowrap;
ย ย background-color: #2c3e50;
ย ย padding: 5px 10px;
ย ย border-radius: 5px;
ย }
ย #continueBtn {
ย ย display: none;
ย ย flex-shrink: 0;
ย }
ย #puzzleWrapper {
ย ย width: 95vw;
ย ย max-width: 1000px;
ย ย aspect-ratio: 4 / 3;
ย ย background: #222;
ย ย position: relative;
ย ย border: 5px solid #333;
ย ย box-sizing: border-box;
ย ย overflow: hidden;
ย ย touch-action: none;
ย }
ย canvas {
ย ย width: 100%; height: 100%; display: block;
ย ย user-select: none;
ย }
ย #completeMsg {
ย ย display: none;
ย ย position: absolute;
ย ย top: 40%; left: 50%;
ย ย transform: translate(-50%, -50%);
ย ย background: rgba(0, 0, 0, 0.8);
ย ย padding: 20px;
ย ย border: 2px solid gold;
ย ย border-radius: 12px;
ย ย text-align: center;
ย ย z-index: 10;
ย ย font-size: 1.2em;
ย ย color: gold;
ย ย text-shadow: 0 0 5px rgba(255,255,255,0.7);
ย }
ย @media (max-width: 600px) {
ย ย body {
ย ย ย font-size: 0.9em;
ย ย }
ย ย h1 {
ย ย ย font-size: 1em;
ย ย }
ย ย #restartBtn, #pauseBtn, #continueBtn {
ย ย ย font-size: 0.6em;
ย ย ย padding: 8px 10px;
ย ย }
ย ย #timer {
ย ย ย font-size: 0.8em;
ย ย }
ย ย #completeMsg {
ย ย ย font-size: 1em;
ย ย ย padding: 15px;
ย ย }
ย }
ย @media (orientation: landscape) {
ย ย h1 {
ย ย ย display: block;
ย ย }
ย ย #puzzleWrapper {
ย ย ย aspect-ratio: 4 / 3;
ย ย }
ย ย #topBar {
ย ย ย width: 95vw;
ย ย ย padding: 0;
ย ย }
ย }
</style>
</head>
<body>
<h1>Puzzle: Plaza de Toros y Estaciรณn del Norte</h1>
<div id="topBar">
ย <div id="leftControls">
ย ย <button id="restartBtn">๐ Reiniciar</button>
ย ย <button id="pauseBtn">โธ๏ธ Pausar</button>
ย ย <span id="timer">Tiempo: 03:00</span>
ย </div>
ย <button id="continueBtn">Continuar</button>
</div>
<div id="puzzleWrapper">
ย <canvas id="puzzleCanvas"></canvas>
ย <div id="completeMsg">
ย ย <strong id="messageText"></strong><br />
ย </div>
</div>

<script>
const puzzleCanvas = document.getElementById("puzzleCanvas");
const ctx = puzzleCanvas.getContext("2d");
const imageSrc = "imagenes_puzzles/P18_puzzle_plaza_de_Toros_y_estacion_norte.jpg"; // ยกRuta de imagen actualizada!
const rows = 3, cols = 4;
let pieces = [], draggingPiece = null;
let offsetX = 0, offsetY = 0, placedCount = 0;
let img = new Image();
let animatingPiece = null, animFrame = 0, animDirection = 1, animScale = 1;
const completeMsg = document.getElementById("completeMsg");
const messageText = document.getElementById("messageText");
const continueBtn = document.getElementById("continueBtn");
const restartBtn = document.getElementById("restartBtn");
const pauseBtn = document.getElementById("pauseBtn");
const timerDisplay = document.getElementById("timer");
const puzzleWrapper = document.getElementById("puzzleWrapper");

const placeSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
const failSound = new Audio("https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg");
const successSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
placeSound.volume = 0.3; failSound.volume = 0.4; successSound.volume = 0.5;

let paused = false, timeLeft = 180, timerInterval;

let puzzleEnded = false;

const effectCanvas = document.createElement("canvas");
const effectCtx = effectCanvas.getContext("2d");
effectCanvas.style.position = "absolute";
effectCanvas.style.top = "0";
effectCanvas.style.left = "0";
effectCanvas.style.pointerEvents = "none";
effectCanvas.style.width = "100%";
effectCanvas.style.height = "100%";
puzzleWrapper.appendChild(effectCanvas);

img.onload = () => { init(); };
img.onerror = () => {
ย console.error("Error al cargar la imagen:", imageSrc);
ย alert("No se pudo cargar la imagen del puzzle. Revisa la ruta.");
};
img.src = imageSrc;

window.addEventListener("resize", resizePieces);
window.addEventListener("orientationchange", () => setTimeout(resizePieces, 300));

function resizePieces() {
ย const w = puzzleWrapper.clientWidth;
ย const h = puzzleWrapper.clientHeight;
ย puzzleCanvas.width = w;
ย puzzleCanvas.height = h;
ย effectCanvas.width = w;
ย effectCanvas.height = h;
ย const pw = w / cols;
ย const ph = h / rows;

ย pieces.forEach(p => {
ย ย const colIndex = Math.round(p.correctX / p.w);
ย ย const rowIndex = Math.round(p.correctY / p.h);
ย ย p.w = pw;
ย ย p.h = ph;
ย ย p.correctX = colIndex * pw;
ย ย p.correctY = rowIndex * ph;

ย ย if (p.placed) {
ย ย ย p.x = p.correctX;
ย ย ย p.y = p.correctY;
ย ย } else {
ย ย ย p.x = Math.min(Math.max(p.x * (w / puzzleCanvas.width), 0), w - pw);
ย ย ย p.y = Math.min(Math.max(p.y * (h / puzzleCanvas.height), 0), h - ph);
ย ย }
ย });
ย draw();
}

function init() {
ย puzzleEnded = false;
ย paused = false;
ย pauseBtn.textContent = 'โธ๏ธ Pausar';
ย completeMsg.style.display = "none";
ย continueBtn.style.display = "none";
ย puzzleWrapper.style.borderColor = "#333";
ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย const w = puzzleWrapper.clientWidth, h = puzzleWrapper.clientHeight;
ย puzzleCanvas.width = w; puzzleCanvas.height = h;
ย effectCanvas.width = w; effectCanvas.height = h;
ย const pw = w / cols, ph = h / rows;

ย pieces = []; placedCount = 0;
ย 
ย for (let r = 0; r < rows; r++) {
ย ย for (let c = 0; c < cols; c++) {
ย ย ย pieces.push({
ย ย ย ย sx: c * img.naturalWidth / cols, sy: r * img.naturalHeight / rows,
ย ย ย ย sw: img.naturalWidth / cols, sh: img.naturalHeight / rows,
ย ย ย ย x: Math.random() * (w - pw), y: Math.random() * (h - ph),
ย ย ย ย w: pw, h: ph, correctX: c * pw, correctY: r * ph,
ย ย ย ย placed: false, scale: 1
ย ย ย });
ย ย }
ย }

ย timeLeft = 180;
ย updateTimerDisplay();
ย startTimer();
ย draw();
}

function draw() {
ย ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
ย 
ย for (const p of pieces.filter(p => p.placed)) {
ย ย drawPiece(p);
ย ย ctx.strokeStyle = '#555';
ย ย ctx.lineWidth = 1;
ย ย ctx.strokeRect(p.x, p.y, p.w, p.h);
ย }
ย for (const p of pieces.filter(p => !p.placed)) {
ย ย drawPiece(p);
ย ย ctx.strokeStyle = '#555';
ย ย ctx.lineWidth = 1;
ย ย ctx.strokeRect(p.x, p.y, p.w, p.h);
ย }

ย if (animatingPiece) {
ย ย animatingPiece.scale = animScale;
ย ย animFrame++;
ย ย animScale += 0.05 * animDirection;
ย ย if (animFrame >= 10) animDirection = -1;
ย ย if (animFrame >= 20) {
ย ย ย animatingPiece.scale = 1;
ย ย ย animatingPiece = null;
ย ย ย animFrame = 0; animDirection = 1; animScale = 1;
ย ย }
ย }
ย 
ย if (!puzzleEnded) {
ย ย requestAnimationFrame(draw);
ย }
}

function drawPiece(piece) {
ย ctx.save();
ย ctx.translate(piece.x + piece.w / 2, piece.y + piece.h / 2);
ย ctx.scale(piece.scale, piece.scale);
ย ctx.translate(-piece.w / 2, -piece.h / 2);
ย ctx.drawImage(img, piece.sx, piece.sy, piece.sw, piece.sh, 0, 0, piece.w, piece.h);
ย ctx.restore();
}

function onPointerDown(e) {
ย if (puzzleEnded || paused) return;
ย const rect = puzzleCanvas.getBoundingClientRect();
ย const x = e.clientX - rect.left;
ย const y = e.clientY - rect.top;
ย for (let i = pieces.length - 1; i >= 0; i--) {
ย ย const p = pieces[i];
ย ย if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
ย ย ย draggingPiece = p;
ย ย ย offsetX = x - p.x;
ย ย ย offsetY = y - p.y;
ย ย ย pieces.splice(i, 1);
ย ย ย pieces.push(draggingPiece);
ย ย ย break;
ย ย }
ย }
}

function onPointerMove(e) {
ย if (!draggingPiece || puzzleEnded || paused) return;
ย const rect = puzzleCanvas.getBoundingClientRect();
ย const x = e.clientX - rect.left;
ย const y = e.clientY - rect.top;
ย draggingPiece.x = Math.min(Math.max(x - offsetX, 0), puzzleCanvas.width - draggingPiece.w);
ย draggingPiece.y = Math.min(Math.max(y - offsetY, 0), puzzleCanvas.height - draggingPiece.h);
ย 
ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
ย const targetPiece = getPieceAt(x, y);
ย if (targetPiece && targetPiece !== draggingPiece) {
ย ย effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
ย ย effectCtx.lineWidth = 3;
ย ย effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.w, targetPiece.h);
ย }
}

function onPointerUp(e) {
ย if (!draggingPiece || puzzleEnded || paused) return;
ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย if (Math.abs(draggingPiece.x - draggingPiece.correctX) < draggingPiece.w / 4 &&
ย ย ย Math.abs(draggingPiece.y - draggingPiece.correctY) < draggingPiece.h / 4) {
ย ย draggingPiece.x = draggingPiece.correctX;
ย ย draggingPiece.y = draggingPiece.correctY;
ย ย if (!draggingPiece.placed) {
ย ย ย draggingPiece.placed = true;
ย ย ย placedCount++;
ย ย ย placeSound.play();
ย ย ย animatingPiece = draggingPiece;
ย ย ย animFrame = 0;
ย ย ย animDirection = 1;
ย ย ย animScale = 1;
ย ย }
ย } else {
ย ย failSound.play();
ย }
ย draggingPiece = null;
ย 
ย if (placedCount === pieces.length) {
ย ย endPuzzle(true);
ย }
}

function getPieceAt(x, y) {
ย for (let i = pieces.length - 1; i >= 0; i--) {
ย ย const p = pieces[i];
ย ย if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
ย ย ย return p;
ย ย }
ย }
ย return null;
}

function startTimer() {
ย clearInterval(timerInterval);
ย timerInterval = setInterval(() => {
ย ย if (!paused && !puzzleEnded) {
ย ย ย timeLeft--;
ย ย ย updateTimerDisplay();
ย ย ย if (timeLeft <= 0) {
ย ย ย ย endPuzzle(false);
ย ย ย }
ย ย }
ย }, 1000);
}

function updateTimerDisplay() {
ย const m = Math.floor(timeLeft / 60);
ย const s = timeLeft % 60;
ย timerDisplay.textContent = `Tiempo: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

function endPuzzle(success) {
ย puzzleEnded = true;
ย clearInterval(timerInterval);
ย continueBtn.style.display = "inline-block";
ย completeMsg.style.display = "block";

ย if (success) {
ย ย successSound.play();
ย ย messageText.textContent = "๐ ยกBravo! ยกPuzzle Completado!";
ย ย puzzleWrapper.style.borderColor = "gold";
ย ย runFireworks();
ย } else {
ย ย messageText.textContent = "โฐ ยกTiempo agotado! Intรฉntalo de nuevo.";
ย ย puzzleWrapper.style.borderColor = "red";
ย ย runConfetti();
ย }

ย window.parent.postMessage(success ? 'puzzle-completed' : 'puzzle-timeout', '*');
}

function runFireworks() {
ย let duration = 5000;
ย let startTime = null;
ย const particles = [];
ย const colors = ["#ff2e2e","#ff7f50","#ffcc00","#3cff5f","#1e90ff","#9b30ff"];

ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย function createParticle(x, y) {
ย ย return {
ย ย ย x, y,
ย ย ย vx: (Math.random() - 0.5) * 6,
ย ย ย vy: (Math.random() - 0.5) * 6,
ย ย ย life: 100,
ย ย ย color: colors[Math.floor(Math.random() * colors.length)],
ย ย ย size: Math.random() * 3 + 2
ย ย };
ย }

ย function loop(timestamp) {
ย ย if (!startTime) startTime = timestamp;
ย ย let elapsed = timestamp - startTime;
ย ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย ย if (elapsed < duration) {
ย ย ย if (particles.length < 100) {
ย ย ย ย let x = Math.random() * effectCanvas.width;
ย ย ย ย let y = Math.random() * effectCanvas.height / 2;
ย ย ย ย for(let i=0; i<5; i++) {
ย ย ย ย ย particles.push(createParticle(x, y));
ย ย ย ย }
ย ย ย }
ย ย ย for (let i = particles.length - 1; i >= 0; i--) {
ย ย ย ย const p = particles[i];
ย ย ย ย p.x += p.vx;
ย ย ย ย p.y += p.vy;
ย ย ย ย p.vy += 0.1;
ย ย ย ย p.life--;
ย ย ย ย if (p.life <= 0) particles.splice(i, 1);
ย ย ย ย else {
ย ย ย ย ย effectCtx.beginPath();
ย ย ย ย ย effectCtx.fillStyle = p.color;
ย ย ย ย ย effectCtx.shadowColor = p.color;
ย ย ย ย ย effectCtx.shadowBlur = 10;
ย ย ย ย ย effectCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
ย ย ย ย ย effectCtx.fill();
ย ย ย ย ย effectCtx.closePath();
ย ย ย ย }
ย ย ย }
ย ย ย requestAnimationFrame(loop);
ย ย } else {
ย ย ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
ย ย }
ย }
ย requestAnimationFrame(loop);
}

function runConfetti() {
ย let duration = 5000;
ย let startTime = null;
ย const confettiPieces = [];
ย const colors = ["#ff0","#f0f","#0ff","#0f0","#00f","#f00"];

ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย function createConfetti() {
ย ย return {
ย ย ย x: Math.random() * effectCanvas.width,
ย ย ย y: Math.random() * -20,
ย ย ย size: Math.random() * 8 + 8,
ย ย ย speedY: Math.random() * 3 + 2,
ย ย ย color: colors[Math.floor(Math.random() * colors.length)],
ย ย ย tilt: Math.random() * 10 - 5,
ย ย ย tiltSpeed: Math.random() * 0.1 + 0.05
ย ย };
ย }

ย for(let i = 0; i < 150; i++) {
ย ย confettiPieces.push(createConfetti());
ย }

ย function loop(timestamp) {
ย ย if (!startTime) startTime = timestamp;
ย ย let elapsed = timestamp - startTime;
ย ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

ย ย if (elapsed < duration) {
ย ย ย confettiPieces.forEach(p => {
ย ย ย ย p.y += p.speedY;
ย ย ย ย p.tilt += p.tiltSpeed;
ย ย ย ย if (p.y > effectCanvas.height) {
ย ย ย ย ย p.x = Math.random() * effectCanvas.width;
ย ย ย ย ย p.y = Math.random() * -20;
ย ย ย ย }
ย ย ย ย effectCtx.save();
ย ย ย ย effectCtx.translate(p.x, p.y);
ย ย ย ย effectCtx.rotate(p.tilt);
ย ย ย ย effectCtx.fillStyle = p.color;
ย ย ย ย effectCtx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
ย ย ย ย effectCtx.restore();
ย ย ย });
ย ย ย requestAnimationFrame(loop);
ย ย } else {
ย ย ย effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
ย ย }
ย }
ย requestAnimationFrame(loop);
}


restartBtn.addEventListener("click", () => {
ย init();
});
pauseBtn.addEventListener("click", () => {
ย paused = !paused;
ย pauseBtn.textContent = paused ? "โถ๏ธ Reanudar" : "โธ๏ธ Pausar";
});

continueBtn.addEventListener("click", () => {
ย completeMsg.style.display = "none";
ย continueBtn.style.display = "none";
});


puzzleCanvas.addEventListener("pointerdown", onPointerDown);
puzzleCanvas.addEventListener("pointermove", onPointerMove);
puzzleCanvas.addEventListener("pointerup", onPointerUp);
puzzleCanvas.addEventListener("pointercancel", onPointerUp);
puzzleCanvas.addEventListener("pointerout", onPointerUp);
puzzleCanvas.addEventListener("pointerleave", onPointerUp);

</script>
</body>
</html>
