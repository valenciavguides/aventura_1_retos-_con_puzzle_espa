<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle 18: Plaza de Toros y Estaci贸n del Norte</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Press Start 2P', cursive;
            color: #ecf0f1;
            overflow: hidden;
        }
        .puzzle-container {
            text-align: center;
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #puzzleWrapper {
            position: relative;
            width: clamp(280px, 80vw, 800px);
            padding-bottom: 56.25%; /* Ratio 16:9 */
            height: 0;
            border: 5px solid #333;
            box-sizing: border-box;
            background-color: #222;
            margin-bottom: 20px;
            overflow: hidden;
            display: block;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        #puzzleCanvas {
            z-index: 1;
        }
        #effectCanvas {
            z-index: 2;
            pointer-events: none;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            background-color: #e67e22;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #d35400;
        }
        #timerDisplay {
            font-size: 1em;
            margin-top: 10px;
            background-color: #2c3e50;
            padding: 5px 10px;
            border-radius: 5px;
        }
        #completeMessage {
            font-size: 1.2em;
            color: gold;
            margin-top: 20px;
            display: none;
        }

        @media (max-width: 600px) {
            .puzzle-container {
                padding: 10px;
            }
            button {
                font-size: 0.6em;
                padding: 8px 10px;
            }
            #timerDisplay {
                font-size: 0.8em;
            }
            #completeMessage {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="puzzle-container">
        <h1>Puzzle: Plaza de Toros y Estaci贸n del Norte</h1>
        <div id="puzzleWrapper">
            <canvas id="puzzleCanvas"></canvas>
            <canvas id="effectCanvas"></canvas>
        </div>
        <div class="controls">
            <button id="restartBtn"> Reiniciar</button>
            <button id="pauseBtn">革 Pausar</button>
        </div>
        <div id="timerDisplay">Tiempo: 00:00</div>
        <div id="completeMessage">隆Puzzle Completado! </div>
    </div>

   <script>
    const puzzleCanvas = document.getElementById('puzzleCanvas');
    const ctx = puzzleCanvas.getContext('2d');
    const effectCanvas = document.getElementById('effectCanvas');
    const effectCtx = effectCanvas.getContext('2d');
    
    const image = new Image();
    // *** RUTA DE IMAGEN PARA PLAZA DE TOROS Y ESTACIN DEL NORTE ***
    const imageSrc = "/imagenes_puzzles/P18_plaza_de_toros_y_estacion_del_norte.jpg"; 

    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const completeMsg = document.getElementById('completeMessage');
    const puzzleWrapper = document.getElementById('puzzleWrapper');
    const timerDisplay = document.getElementById('timerDisplay');
    let puzzlePieces = [];
    let cols = 4; 
    let rows = 3; 
    let pieceWidth, pieceHeight;
    let currentPiece = null;
    let offsetX, offsetY;
    let startTime, timerInterval;
    let paused = false;
    let puzzleEnded = false; 

    image.onload = () => {
        resizeCanvas(); 
        init(); 
    };
    image.onerror = () => {
        console.error("Error al cargar la imagen:", imageSrc);
        alert("No se pudo cargar la imagen del puzzle. Intenta recargar la p谩gina.");
    };
    image.src = imageSrc;

    function resizeCanvas() {
        const wrapperRect = puzzleWrapper.getBoundingClientRect();
        
        puzzleCanvas.width = wrapperRect.width;
        puzzleCanvas.height = wrapperRect.height;
        effectCanvas.width = wrapperRect.width;
        effectCanvas.height = wrapperRect.height;

        if (puzzlePieces.length > 0) {
            pieceWidth = puzzleCanvas.width / cols;
            pieceHeight = puzzleCanvas.height / rows;
            drawPuzzle(); 
        }
    }

    function init() {
        puzzleEnded = false;
        completeMsg.style.display = 'none';
        puzzleWrapper.style.borderColor = '#333';
        paused = false;
        pauseBtn.textContent = '革 Pausar';
        timerDisplay.textContent = 'Tiempo: 00:00';
        clearInterval(timerInterval);

        pieceWidth = puzzleCanvas.width / cols;
        pieceHeight = puzzleCanvas.height / rows;

        createPieces();
        shufflePieces();
        drawPuzzle();
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
    }

    function createPieces() {
        puzzlePieces = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                puzzlePieces.push({
                    x: c * pieceWidth, 
                    y: r * pieceHeight,
                    originalX: c * pieceWidth, 
                    originalY: r * pieceHeight,
                    width: pieceWidth,
                    height: pieceHeight,
                    row: r,
                    col: c,
                    originalRow: r,
                    originalCol: c,
                });
            }
        }
    }

    function shufflePieces() {
        for (let i = puzzlePieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [puzzlePieces[i].x, puzzlePieces[j].x] = [puzzlePieces[j].x, puzzlePieces[i].x];
            [puzzlePieces[i].y, puzzlePieces[j].y] = [puzzlePieces[j].y, puzzlePieces[i].y];
        }
    }

    function drawPuzzle() {
        ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        puzzlePieces.forEach(piece => {
            ctx.drawImage(
                image,
                piece.originalX * (image.naturalWidth / puzzleCanvas.width), 
                piece.originalY * (image.naturalHeight / puzzleCanvas.height), 
                piece.width * (image.naturalWidth / puzzleCanvas.width), 
                piece.height * (image.naturalHeight / puzzleCanvas.height), 
                piece.x, 
                piece.y, 
                piece.width, 
                piece.height 
            );
            ctx.strokeStyle = '#555'; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
        });
    }

    function getPieceAt(x, y) {
        for (let i = puzzlePieces.length - 1; i >= 0; i--) {
            const piece = puzzlePieces[i];
            if (x > piece.x && x < piece.x + piece.width &&
                y > piece.y && y < piece.y + piece.height) {
                return piece;
            }
        }
        return null;
    }

    function swapPieces(p1, p2) {
        [p1.x, p2.x] = [p2.x, p1.x];
        [p1.y, p2.y] = [p2.y, p1.y];
        drawPuzzle();
        if (checkWin()) {
            endPuzzle();
        }
    }

    function checkWin() {
        for (let i = 0; i < puzzlePieces.length; i++) {
            const piece = puzzlePieces[i];
            if (piece.x !== piece.originalX || piece.y !== piece.originalY) {
                return false;
            }
        }
        return true;
    }

    function endPuzzle() {
        puzzleEnded = true;
        clearInterval(timerInterval);
        completeMsg.style.display = 'block';
        puzzleWrapper.style.borderColor = 'gold';
        window.parent.postMessage('puzzle-completed', '*');
    }

    function updateTimer() {
        if (paused || puzzleEnded) return;
        const currentTime = Date.now();
        const elapsedTime = Math.floor((currentTime - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        timerDisplay.textContent = `Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function handleMouseDown(e) {
        if (paused || puzzleEnded) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentPiece = getPieceAt(x, y);
        if (currentPiece) {
            offsetX = x - currentPiece.x;
            offsetY = y - currentPiece.y;
            puzzlePieces = puzzlePieces.filter(p => p !== currentPiece);
            puzzlePieces.push(currentPiece);
            drawPuzzle();
            effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        }
    }

    function handleMouseMove(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        currentPiece.x = x - offsetX;
        currentPiece.y = y - offsetY;
        drawPuzzle();

        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        const targetPiece = getPieceAt(x, y);
        if (targetPiece && targetPiece !== currentPiece) {
            effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            effectCtx.lineWidth = 3;
            effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.width, targetPiece.height);
        }
    }

    function handleMouseUp(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        const rect = puzzleCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const targetPiece = getPieceAt(mouseX, mouseY);

        if (targetPiece && targetPiece !== currentPiece) {
            swapPieces(currentPiece, targetPiece);
        } 
        currentPiece = null;
        drawPuzzle();
    }

    function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        handleMouseUp({});
    }

    puzzleCanvas.addEventListener('mousedown', handleMouseDown);
    puzzleCanvas.addEventListener('mousemove', handleMouseMove);
    puzzleCanvas.addEventListener('mouseup', handleMouseUp);
    puzzleCanvas.addEventListener('mouseleave', handleMouseUp);

    puzzleCanvas.addEventListener('touchstart', handleTouchStart);
    puzzleCanvas.addEventListener('touchmove', handleTouchMove);
    puzzleCanvas.addEventListener('touchend', handleTouchEnd);
    puzzleCanvas.addEventListener('touchcancel', handleTouchEnd);

    restartBtn.addEventListener('click', init);
    pauseBtn.addEventListener('click', () => {
        paused = !paused;
        if (paused) {
            pauseBtn.textContent = '讹 Reanudar';
            clearInterval(timerInterval);
        } else {
            pauseBtn.textContent = '革 Pausar';
            const currentTime = Date.now();
            const currentElapsedTime = Math.floor((currentTime - startTime) / 1000);
            startTime = Date.now() - currentElapsedTime * 1000;
            timerInterval = setInterval(updateTimer, 1000);
        }
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); 
</script>
</body>
</html>
