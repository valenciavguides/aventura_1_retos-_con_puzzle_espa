<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Puzzle 8: Plaza de la Virgen</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    background: #2c3e50; /* Color de fondo unificado de tu primer código */
    font-family: 'Press Start 2P', cursive; /* Fuente de tu primer código */
    color: #ecf0f1; /* Color de texto de tu primer código */
    display: flex; flex-direction: column;
    align-items: center; justify-content: flex-start;
    overflow: hidden; /* Evita scroll en dispositivos móviles */
  }
  h1 {
    font-size: 1.2em;
    margin: 8px;
    text-align: center;
  }
  #topBar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
    width: 95vw;
    max-width: 1000px;
    gap: 10px;
    flex-wrap: nowrap;
  }
  #leftControls {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-shrink: 1;
    min-width: 0;
  }
  #restartBtn, #pauseBtn, #continueBtn { /* Unificado para los botones */
    background-color: #e67e22; /* Color de botón de tu primer código */
    color: white; /* Color de texto de botón de tu primer código */
    border: none; /* Sin borde como en tu primer código */
    padding: 10px 15px; /* Padding de tu primer código */
    border-radius: 5px; /* Border-radius de tu primer código */
    cursor: pointer;
    font-family: 'Press Start 2P', cursive; /* Fuente de tu primer código */
    font-size: 0.7em; /* Ajuste para pantallas pequeñas de tu primer código */
    transition: background-color 0.3s ease;
    white-space: nowrap;
  }
  #restartBtn:hover, #pauseBtn:hover, #continueBtn:hover {
    background-color: #d35400; /* Hover de tu primer código */
  }
  #timer {
    font-size: 1em;
    font-weight: bold;
    min-width: 60px;
    text-align: center;
    white-space: nowrap;
    background-color: #2c3e50; /* Color de fondo del temporizador de tu primer código */
    padding: 5px 10px; /* Padding de tu primer código */
    border-radius: 5px; /* Border-radius de tu primer código */
  }
  #continueBtn {
    display: none; /* Inicialmente oculto */
    flex-shrink: 0;
  }
  #puzzleWrapper {
    width: 95vw;
    max-width: 1000px;
    aspect-ratio: 4 / 3; /* Ratio de tu primer código (4:3), si tus imágenes son 16:9 ajusta a 16 / 9 */
    background: #222; /* Color de fondo de tu primer código */
    position: relative;
    border: 5px solid #333; /* Grosor de borde igual como solicitaste */
    box-sizing: border-box; /* Asegura que el padding/border no aumenten el tamaño total */
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    width: 100%; height: 100%; display: block;
    user-select: none;
  }
  #completeMsg {
    display: none;
    position: absolute;
    top: 40%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8); /* Fondo más oscuro para el mensaje */
    padding: 20px;
    border: 2px solid gold; /* Borde dorado para el mensaje de éxito */
    border-radius: 12px;
    text-align: center;
    z-index: 10;
    font-size: 1.2em;
    color: gold; /* Color de texto dorado para el mensaje */
    text-shadow: 0 0 5px rgba(255,255,255,0.7);
  }
  /* Media Queries para responsividad */
  @media (max-width: 600px) {
    body {
      font-size: 0.9em;
    }
    h1 {
      font-size: 1em;
    }
    #restartBtn, #pauseBtn, #continueBtn {
      font-size: 0.6em;
      padding: 8px 10px;
    }
    #timer {
      font-size: 0.8em;
    }
    #completeMsg {
      font-size: 1em;
      padding: 15px;
    }
  }
  @media (orientation: landscape) {
    h1 {
      display: block; /* Muestra el título en horizontal si lo deseas, o cámbialo a 'none' */
    }
    #puzzleWrapper {
      /* Mantengo el ratio de tu primer código, ajusta a 16 / 9 si tus imágenes son apaisadas y quieres llenarlo */
      aspect-ratio: 4 / 3;
    }
    #topBar {
      width: 95vw; /* Mantener un poco de margen en horizontal */
      padding: 0;
    }
  }
</style>
</head>
<body>
<h1>Puzzle: Plaza de la Virgen</h1>
<div id="topBar">
  <div id="leftControls">
    <button id="restartBtn">🔄 Reiniciar</button>
    <button id="pauseBtn">⏸️ Pausar</button>
    <span id="timer">Tiempo: 03:00</span>
  </div>
  <button id="continueBtn">Continuar</button>
</div>
<div id="puzzleWrapper">
  <canvas id="puzzleCanvas"></canvas>
  <div id="completeMsg">
    <strong id="messageText"></strong><br />
  </div>
</div>

<script>
const puzzleCanvas = document.getElementById("puzzleCanvas");
const ctx = puzzleCanvas.getContext("2d");
const imageSrc = "imagenes_puzzles/P8_plaza_de_la_virgen.jpg"; // Tu ruta de imagen validada
const rows = 3, cols = 4;
let pieces = [], draggingPiece = null;
let offsetX = 0, offsetY = 0, placedCount = 0;
let img = new Image();
let animatingPiece = null, animFrame = 0, animDirection = 1, animScale = 1;
const completeMsg = document.getElementById("completeMsg");
const messageText = document.getElementById("messageText");
const continueBtn = document.getElementById("continueBtn");
const restartBtn = document.getElementById("restartBtn");
const pauseBtn = document.getElementById("pauseBtn");
const timerDisplay = document.getElementById("timer");
const puzzleWrapper = document.getElementById("puzzleWrapper");

// Sonidos (URLs de tu segundo código)
const placeSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
const failSound = new Audio("https://actions.google.com/sounds/v1/cartoon/concussive_hit_guitar_boing.ogg");
const successSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
placeSound.volume = 0.3; failSound.volume = 0.4; successSound.volume = 0.5;

let paused = false, timeLeft = 180, timerInterval; // 3 minutos de tiempo

let puzzleEnded = false;

// Canvas de efectos (como en tu segundo código)
const effectCanvas = document.createElement("canvas");
const effectCtx = effectCanvas.getContext("2d");
effectCanvas.style.position = "absolute";
effectCanvas.style.top = "0";
effectCanvas.style.left = "0";
effectCanvas.style.pointerEvents = "none";
effectCanvas.style.width = "100%";
effectCanvas.style.height = "100%";
puzzleWrapper.appendChild(effectCanvas);

img.onload = () => { init(); };
img.onerror = () => {
  console.error("Error al cargar la imagen:", imageSrc);
  alert("No se pudo cargar la imagen del puzzle. Revisa la ruta.");
};
img.src = imageSrc;

window.addEventListener("resize", resizePieces);
window.addEventListener("orientationchange", () => setTimeout(resizePieces, 300));

function resizePieces() {
  const w = puzzleWrapper.clientWidth;
  const h = puzzleWrapper.clientHeight;
  puzzleCanvas.width = w; // Asegúrate de que puzzleCanvas se resize
  puzzleCanvas.height = h;
  effectCanvas.width = w;
  effectCanvas.height = h;
  const pw = w / cols;
  const ph = h / rows;

  pieces.forEach(p => {
    // Recalcular correctX/Y para mantener la posición relativa al nuevo tamaño del canvas
    const colIndex = Math.round(p.correctX / p.w);
    const rowIndex = Math.round(p.correctY / p.h);
    p.w = pw;
    p.h = ph;
    p.correctX = colIndex * pw;
    p.correctY = rowIndex * ph;

    if (p.placed) {
      p.x = p.correctX;
      p.y = p.correctY;
    } else {
      // Ajusta la posición de las piezas no colocadas al nuevo tamaño del canvas
      // Evita que se salgan del canvas
      p.x = Math.min(Math.max(p.x * (w / puzzleCanvas.width), 0), w - pw);
      p.y = Math.min(Math.max(p.y * (h / puzzleCanvas.height), 0), h - ph);
    }
  });
  draw();
}

function init() {
  puzzleEnded = false;
  paused = false;
  pauseBtn.textContent = '⏸️ Pausar';
  completeMsg.style.display = "none";
  continueBtn.style.display = "none";
  puzzleWrapper.style.borderColor = "#333";
  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height); // Limpiar efectos

  const w = puzzleWrapper.clientWidth, h = puzzleWrapper.clientHeight;
  puzzleCanvas.width = w; puzzleCanvas.height = h;
  effectCanvas.width = w; effectCanvas.height = h;
  const pw = w / cols, ph = h / rows;

  pieces = []; placedCount = 0;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      pieces.push({
        sx: c * img.naturalWidth / cols, sy: r * img.naturalHeight / rows,
        sw: img.naturalWidth / cols, sh: img.naturalHeight / rows,
        x: Math.random() * (w - pw), y: Math.random() * (h - ph),
        w: pw, h: ph, correctX: c * pw, correctY: r * ph,
        placed: false, scale: 1
      });
    }
  }

  timeLeft = 180; // Reiniciar tiempo a 3 minutos
  updateTimerDisplay();
  startTimer();
  draw();
}

function draw() {
  ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
  
  // Dibujar piezas ya colocadas primero (para que las no colocadas se superpongan)
  for (const p of pieces.filter(p => p.placed)) {
    drawPiece(p);
    ctx.strokeStyle = '#555'; /* Borde de pieza de tu primer código */
    ctx.lineWidth = 1; /* Grosor de borde igual */
    ctx.strokeRect(p.x, p.y, p.w, p.h);
  }
  // Dibujar piezas no colocadas
  for (const p of pieces.filter(p => !p.placed)) {
    drawPiece(p);
    ctx.strokeStyle = '#555'; /* Borde de pieza de tu primer código */
    ctx.lineWidth = 1; /* Grosor de borde igual */
    ctx.strokeRect(p.x, p.y, p.w, p.h);
  }

  // Animación de pieza (del segundo código)
  if (animatingPiece) {
    animatingPiece.scale = animScale;
    animFrame++;
    animScale += 0.05 * animDirection;
    if (animFrame >= 10) animDirection = -1;
    if (animFrame >= 20) {
      animatingPiece.scale = 1;
      animatingPiece = null;
      animFrame = 0; animDirection = 1; animScale = 1;
    }
  }
  
  if (!puzzleEnded) { // Solo si el puzzle no ha terminado, sigue dibujando
    requestAnimationFrame(draw);
  }
}

function drawPiece(piece) {
  ctx.save();
  ctx.translate(piece.x + piece.w / 2, piece.y + piece.h / 2);
  ctx.scale(piece.scale, piece.scale);
  ctx.translate(-piece.w / 2, -piece.h / 2);
  ctx.drawImage(img, piece.sx, piece.sy, piece.sw, piece.sh, 0, 0, piece.w, piece.h);
  ctx.restore();
}

function onPointerDown(e) {
  if (puzzleEnded || paused) return;
  const rect = puzzleCanvas.getBoundingClientRect(); // Usar puzzleCanvas
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  for (let i = pieces.length - 1; i >= 0; i--) {
    const p = pieces[i];
    if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
      draggingPiece = p;
      offsetX = x - p.x;
      offsetY = y - p.y;
      // Mueve la pieza al final del array para que se dibuje encima de las demás
      pieces.splice(i, 1);
      pieces.push(draggingPiece);
      break;
    }
  }
}

function onPointerMove(e) {
  if (!draggingPiece || puzzleEnded || paused) return;
  const rect = puzzleCanvas.getBoundingClientRect(); // Usar puzzleCanvas
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  draggingPiece.x = Math.min(Math.max(x - offsetX, 0), puzzleCanvas.width - draggingPiece.w);
  draggingPiece.y = Math.min(Math.max(y - offsetY, 0), puzzleCanvas.height - draggingPiece.h);
  
  // Efecto de borde al arrastrar (del primer código)
  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
  const targetPiece = getPieceAt(x, y); // Función para obtener pieza en (x,y)
  if (targetPiece && targetPiece !== draggingPiece) {
    effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
    effectCtx.lineWidth = 3;
    effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.w, targetPiece.h);
  }
}

function onPointerUp(e) {
  if (!draggingPiece || puzzleEnded || paused) return;
  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height); // Limpiar efecto de borde

  // Lógica de colocación y sonido
  if (Math.abs(draggingPiece.x - draggingPiece.correctX) < draggingPiece.w / 4 &&
      Math.abs(draggingPiece.y - draggingPiece.correctY) < draggingPiece.h / 4) {
    draggingPiece.x = draggingPiece.correctX;
    draggingPiece.y = draggingPiece.correctY;
    if (!draggingPiece.placed) { // Solo si no estaba colocada antes
      draggingPiece.placed = true;
      placedCount++;
      placeSound.play();
      animatingPiece = draggingPiece;
      animFrame = 0;
      animDirection = 1;
      animScale = 1; // Reiniciar escala para la animación
    }
  } else {
    // Si no se coloca en el lugar correcto, reproduce el sonido de fallo
    failSound.play();
  }
  draggingPiece = null;
  
  if (placedCount === pieces.length) {
    endPuzzle(true);
  }
}

// Helper para obtener pieza en (x,y) - necesaria para el efecto de borde
function getPieceAt(x, y) {
  for (let i = pieces.length - 1; i >= 0; i--) {
    const p = pieces[i];
    if (!p.placed && x >= p.x && x <= p.x + p.w && y >= p.y && y <= p.y + p.h) {
      return p;
    }
  }
  return null;
}

function startTimer() {
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!paused && !puzzleEnded) {
      timeLeft--;
      updateTimerDisplay();
      if (timeLeft <= 0) {
        endPuzzle(false);
      }
    }
  }, 1000);
}

function updateTimerDisplay() {
  const m = Math.floor(timeLeft / 60);
  const s = timeLeft % 60;
  timerDisplay.textContent = `Tiempo: ${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
}

function endPuzzle(success) {
  puzzleEnded = true;
  clearInterval(timerInterval);
  continueBtn.style.display = "inline-block";
  completeMsg.style.display = "block";

  if (success) {
    successSound.play();
    messageText.textContent = "🎉 ¡Bravo! ¡Puzzle Completado!";
    puzzleWrapper.style.borderColor = "gold";
    runFireworks();
  } else {
    messageText.textContent = "⏰ ¡Tiempo agotado! Inténtalo de nuevo."; // Mensaje de fallo más amigable
    puzzleWrapper.style.borderColor = "red";
    runConfetti();
  }

  // La función continueBtn.onclick se gestionará en el listener global.
  // Aquí solo hacemos un postMessage a la ventana padre.
  window.parent.postMessage(success ? 'puzzle-completed' : 'puzzle-timeout', '*');
}

// Funciones de efectos (Fuegos artificiales y Confeti)
// **Mantengo las funciones tal cual las proporcionaste, ya que te gustaban**

function runFireworks() {
  let duration = 5000;
  let startTime = null;
  const particles = [];
  const colors = ["#ff2e2e","#ff7f50","#ffcc00","#3cff5f","#1e90ff","#9b30ff"];

  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

  function createParticle(x, y) {
    return {
      x, y,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 100,
      color: colors[Math.floor(Math.random() * colors.length)],
      size: Math.random() * 3 + 2
    };
  }

  function loop(timestamp) {
    if (!startTime) startTime = timestamp;
    let elapsed = timestamp - startTime;
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

    if (elapsed < duration) {
      if (particles.length < 100) {
        let x = Math.random() * effectCanvas.width;
        let y = Math.random() * effectCanvas.height / 2;
        for(let i=0; i<5; i++) {
          particles.push(createParticle(x, y));
        }
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.1;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
        else {
          effectCtx.beginPath();
          effectCtx.fillStyle = p.color;
          effectCtx.shadowColor = p.color;
          effectCtx.shadowBlur = 10;
          effectCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          effectCtx.fill();
          effectCtx.closePath();
        }
      }
      requestAnimationFrame(loop);
    } else {
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
  }
  requestAnimationFrame(loop);
}

function runConfetti() {
  let duration = 5000;
  let startTime = null;
  const confettiPieces = [];
  const colors = ["#ff0","#f0f","#0ff","#0f0","#00f","#f00"];

  effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

  function createConfetti() {
    return {
      x: Math.random() * effectCanvas.width,
      y: Math.random() * -20,
      size: Math.random() * 8 + 8,
      speedY: Math.random() * 3 + 2,
      color: colors[Math.floor(Math.random() * colors.length)],
      tilt: Math.random() * 10 - 5,
      tiltSpeed: Math.random() * 0.1 + 0.05
    };
  }

  for(let i = 0; i < 150; i++) {
    confettiPieces.push(createConfetti());
  }

  function loop(timestamp) {
    if (!startTime) startTime = timestamp;
    let elapsed = timestamp - startTime;
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

    if (elapsed < duration) {
      confettiPieces.forEach(p => {
        p.y += p.speedY;
        p.tilt += p.tiltSpeed;
        if (p.y > effectCanvas.height) {
          p.x = Math.random() * effectCanvas.width;
          p.y = Math.random() * -20;
        }
        effectCtx.save();
        effectCtx.translate(p.x, p.y);
        effectCtx.rotate(p.tilt);
        effectCtx.fillStyle = p.color;
        effectCtx.fillRect(-p.size/2, -p.size/4, p.size, p.size/2);
        effectCtx.restore();
      });
      requestAnimationFrame(loop);
    } else {
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
  }
  requestAnimationFrame(loop);
}


restartBtn.addEventListener("click", () => {
  init(); // Reinicia el juego
});
pauseBtn.addEventListener("click", () => {
  paused = !paused;
  pauseBtn.textContent = paused ? "▶️ Reanudar" : "⏸️ Pausar"; // Cambiado "Continuar" por "Reanudar" para más claridad
});

// Este botón ahora solo desencadena el mensaje, la lógica de navegación está fuera.
continueBtn.addEventListener("click", () => {
  // Simplemente ocultamos el mensaje y el botón, la navegación ya se envió al padre
  completeMsg.style.display = "none";
  continueBtn.style.display = "none";
});


puzzleCanvas.addEventListener("pointerdown", onPointerDown);
puzzleCanvas.addEventListener("pointermove", onPointerMove);
puzzleCanvas.addEventListener("pointerup", onPointerUp);
puzzleCanvas.addEventListener("pointercancel", onPointerUp);
puzzleCanvas.addEventListener("pointerout", onPointerUp);
puzzleCanvas.addEventListener("pointerleave", onPointerUp);

</script>
</body>
</html>
