<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Puzzle Interactivo</title>
<style>
/* Ajustes generales */
html, body {
  margin: 0; padding: 0; height: 100%;
  background: #f0f0f0;
  font-family: sans-serif;
  display: flex; flex-direction: column;
  align-items: center; justify-content: flex-start;
  font-size: 16px; /* Asegura un tama√±o base para 'em' y 'rem' */
}

h1 {
  /* Adaptamos el tama√±o del t√≠tulo del puzzle */
  font-size: clamp(1.2em, 4vw, 1.8em); /* Tama√±o flexible: min 1.2em, ideal 4vw, max 1.8em */
  margin: 8px;
  text-align: center;
  padding: 0 5px; /* Peque√±o padding horizontal para evitar que el texto toque los bordes */
}

#topBar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
  width: 95vw;
  max-width: 1000px;
  gap: 10px;
  /* ¬°IMPORTANTE! Permitir que los elementos se envuelvan en pantallas peque√±as */
  flex-wrap: wrap; /* Cambiado de 'nowrap' a 'wrap' */
  padding: 0 5px; /* Peque√±o padding horizontal */
  box-sizing: border-box; /* Asegura que el padding no cause desbordamiento */
}

#leftControls {
  display: flex;
  gap: 10px;
  align-items: center;
  flex-shrink: 1;
  min-width: 0; /* Permite que el contenedor se encoja */
  flex-wrap: wrap; /* Para que los botones dentro tambi√©n se envuelvan si es necesario */
  justify-content: flex-start; /* Alineaci√≥n para cuando se envuelvan */
}

/* Botones de control (Reiniciar, Pausar) y de chat (Enviar) */
#restartBtn, #pauseBtn, #sendBtn {
  /* Usamos clamp para un padding y tama√±o de fuente responsivos */
  padding: clamp(6px, 1.5vw, 10px) clamp(10px, 3vw, 20px);
  font-size: clamp(0.8em, 2.5vw, 1em);
  background: white;
  border: 1px solid #ccc; /* Bordes de igual grosor */
  border-radius: 5px;
  cursor: pointer;
  white-space: nowrap; /* Evita que el texto del bot√≥n se rompa en varias l√≠neas */
  flex-shrink: 0; /* Evita que el bot√≥n se encoja demasiado */
  height: auto; /* Permite que la altura se ajuste al contenido */
  box-sizing: border-box; /* Incluye padding y borde en el tama√±o total */
}
#pauseBtn {
  background: #f0f0f0; /* Color diferente para el bot√≥n de pausa */
}
#restartBtn:active, #pauseBtn:active, #sendBtn:active {
    transform: translateY(1px); /* Efecto al presionar */
}

/* Campo de entrada de mensaje */
#messageInput {
  flex-grow: 1; /* Permite que el input ocupe el espacio disponible */
  padding: clamp(6px, 1.5vw, 10px);
  font-size: clamp(0.8em, 2.5vw, 1em);
  border: 1px solid #ccc; /* Bordes de igual grosor */
  border-radius: 5px;
  min-width: 0; /* Importante para que no desborde en flexbox */
  box-sizing: border-box;
}

/* Mensaje de completado y controles de tiempo/movimientos */
#completeMsg {
  font-size: clamp(1em, 3vw, 1.5em); /* Mensaje responsivo */
  margin-top: 20px;
  text-align: center;
  color: green;
  font-weight: bold;
}

#timer, #moves {
  font-size: clamp(0.9em, 2.5vw, 1.1em); /* Tama√±os responsivos */
  white-space: nowrap; /* Evita que el texto se rompa */
  flex-shrink: 0; /* Evita que se encoja demasiado */
}

/* Contenedor del puzzle y lienzo */
#puzzleWrapper {
  position: relative;
  /* Asegura que el borde tenga igual grosor */
  border: 3px solid #333;
  border-radius: 8px;
  box-sizing: border-box; /* Incluye borde y padding en el tama√±o */
  overflow: hidden; /* Importante para que el borde se vea bien */
  /* El JavaScript ajustar√° el tama√±o exacto del canvas */
  max-width: 95vw; /* M√°s margen para pantallas peque√±as */
  max-height: 80vh; /* Permite que el puzzle ocupe m√°s altura */
  min-width: 250px; /* M√≠nimo para que sea jugable */
  min-height: 250px; /* M√≠nimo para que sea jugable */
  width: 100%; /* Asegura que el wrapper use todo el ancho disponible hasta max-width */
  height: auto; /* Permite que la altura se ajuste, el JS luego lo fijar√° */
  aspect-ratio: 1 / 1; /* Mantiene la proporci√≥n cuadrada del puzzle si es el caso */
}

canvas {
  display: block;
  /* Los bordes deben ser siempre de igual grosor: Esto ya lo gestiona #puzzleWrapper */
  /* Asegurarse de que el canvas no tenga bordes adicionales */
  border: none;
}

/* Media Queries (ajustes espec√≠ficos para pantallas muy peque√±as) */
@media (max-width: 480px) {
  #topBar {
    flex-direction: column; /* Apilar controles en pantallas muy estrechas */
    align-items: center; /* Centrar al apilar */
  }
  #leftControls {
    width: 100%; /* Ocupar todo el ancho disponible */
    justify-content: center; /* Centrar botones si hay dos */
    margin-bottom: 5px; /* Espacio entre filas */
  }
  #messageInput {
    width: 100%; /* Ocupar todo el ancho disponible */
    margin-top: 5px; /* Espacio entre input y botones */
  }
  #sendBtn {
    width: 100%; /* Ocupar todo el ancho disponible */
    margin-top: 5px; /* Espacio entre input y botones */
  }
}
</style>
</head>
<body>
<h1>Puzzle Plaza de la Virgen</h1>
<div id="topBar">
  <div id="leftControls">
    <button id="restartBtn">üîÑ Reiniciar</button>
    <button id="pauseBtn">‚è∏Ô∏è Pausa</button>
    <span id="timer">03:00</span>
  </div>
</div>
<div id="puzzleWrapper">
  <canvas id="puzzleCanvas"></canvas>
  <div id="completeMsg">
    <strong id="messageText"></strong><br />
  </div>
</div>
<script>
  const puzzleCanvas = document.getElementById('puzzleCanvas');
  const ctx = puzzleCanvas.getContext('2d');
  const effectCanvas = document.getElementById('effectCanvas');
  const effectCtx = effectCanvas.getContext('2d');
  
  const image = new Image();
  const imageSrc = "imagenes_puzzles/P8_plaza_de_la_virgen.jpg"; // Ruta de la imagen para este puzzle
  
  // *** INICIO DE LAS L√çNEAS CLAVE CORREGIDAS ***
  image.onload = () => {
    // Cuando la imagen cargue, llama a la funci√≥n init
    init(); 
  };
  image.src = imageSrc; // ¬°Esta l√≠nea INICIA LA CARGA DE LA IMAGEN!
  // *** FIN DE LAS L√çNEAS CLAVE CORREGIDAS ***

  const restartBtn = document.getElementById('restartBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const completeMsg = document.getElementById('completeMessage');
  const puzzleWrapper = document.getElementById('puzzleWrapper');
  const timerDisplay = document.getElementById('timerDisplay');
  let puzzlePieces = [];
  let cols = 4; // N√∫mero de columnas
  let rows = 3; // N√∫mero de filas
  let pieceWidth, pieceHeight;
  let currentPiece = null;
  let offsetX, offsetY;
  let startTime, timerInterval;
  let paused = false;
  let puzzleEnded = false; 

  function resizeCanvas() {
    const wrapperRect = puzzleWrapper.getBoundingClientRect();
    puzzleCanvas.width = wrapperRect.width;
    puzzleCanvas.height = wrapperRect.height;
    effectCanvas.width = wrapperRect.width;
    effectCanvas.height = wrapperRect.height;

    if (image.complete && image.naturalWidth > 0) {
      drawPuzzle(); 
    }
  }

  function init() {
    puzzleEnded = false;
    completeMsg.style.display = 'none';
    puzzleWrapper.style.borderColor = '#333';
    paused = false;
    pauseBtn.textContent = '‚è∏Ô∏è Pausar';
    timerDisplay.textContent = 'Tiempo: 00:00';
    clearInterval(timerInterval);

    // Estas llamadas estaban dentro de image.onload, ahora se ejecutan despu√©s de que init sea llamado por onload
    pieceWidth = puzzleCanvas.width / cols;
    pieceHeight = puzzleCanvas.height / rows;
    createPieces();
    shufflePieces();
    drawPuzzle();
    startTime = Date.now();
    timerInterval = setInterval(updateTimer, 1000);
  }

  function createPieces() {
    puzzlePieces = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        puzzlePieces.push({
          x: c * pieceWidth,
          y: r * pieceHeight,
          originalX: c * pieceWidth,
          originalY: r * pieceHeight,
          width: pieceWidth,
          height: pieceHeight,
          row: r,
          col: c,
          originalRow: r,
          originalCol: c,
        });
      }
    }
  }

  function shufflePieces() {
    for (let i = puzzlePieces.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [puzzlePieces[i], puzzlePieces[j]] = [puzzlePieces[j], puzzlePieces[i]];
    }
    // Asegurarse de que la pieza vac√≠a no est√© en la √∫ltima posici√≥n (para el puzzle de 15)
    // Aunque este puzzle es de 12 piezas, es buena pr√°ctica si se a√±ade una pieza vac√≠a.
  }

  function drawPuzzle() {
    ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

    puzzlePieces.forEach(piece => {
      ctx.drawImage(
        image,
        piece.originalX * (image.naturalWidth / puzzleCanvas.width), // sx
        piece.originalY * (image.naturalHeight / puzzleCanvas.height), // sy
        piece.width * (image.naturalWidth / puzzleCanvas.width), // sWidth
        piece.height * (image.naturalHeight / puzzleCanvas.height), // sHeight
        piece.x, // dx
        piece.y, // dy
        piece.width, // dWidth
        piece.height // dHeight
      );
      // Dibujar borde para cada pieza
      ctx.strokeStyle = '#555'; // Color del borde de las piezas
      ctx.lineWidth = 1; // Grosor del borde de las piezas
      ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
    });
  }

  function getPieceAt(x, y) {
    for (let i = puzzlePieces.length - 1; i >= 0; i--) {
      const piece = puzzlePieces[i];
      if (x > piece.x && x < piece.x + piece.width &&
          y > piece.y && y < piece.y + piece.height) {
        return piece;
      }
    }
    return null;
  }

  function swapPieces(p1, p2) {
    [p1.x, p2.x] = [p2.x, p1.x];
    [p1.y, p2.y] = [p2.y, p1.y];
    drawPuzzle();
    if (checkWin()) {
      endPuzzle();
    }
  }

  function checkWin() {
    for (let i = 0; i < puzzlePieces.length; i++) {
      const piece = puzzlePieces[i];
      if (piece.x !== piece.originalX || piece.y !== piece.originalY) {
        return false;
      }
    }
    return true;
  }

  function endPuzzle() {
    puzzleEnded = true;
    clearInterval(timerInterval);
    completeMsg.style.display = 'block';
    puzzleWrapper.style.borderColor = 'gold'; // Cambiar color del borde al completar
  }

  function updateTimer() {
    if (paused || puzzleEnded) return;
    const currentTime = Date.now();
    const elapsedTime = Math.floor((currentTime - startTime) / 1000);
    const minutes = Math.floor(elapsedTime / 60);
    const seconds = elapsedTime % 60;
    timerDisplay.textContent = `Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  function handleMouseDown(e) {
    if (paused || puzzleEnded) return;
    const rect = puzzleCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    currentPiece = getPieceAt(x, y);
    if (currentPiece) {
      offsetX = x - currentPiece.x;
      offsetY = y - currentPiece.y;
      // Mover la pieza seleccionada al final del array para que se dibuje encima
      puzzlePieces = puzzlePieces.filter(p => p !== currentPiece);
      puzzlePieces.push(currentPiece);
      drawPuzzle(); // Redibujar para que la pieza seleccionada est√© encima
      // Limpiar efectos de arrastre
      effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    }
  }

  function handleMouseMove(e) {
    if (paused || puzzleEnded || !currentPiece) return;
    const rect = puzzleCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    currentPiece.x = x - offsetX;
    currentPiece.y = y - offsetY;
    drawPuzzle(); // Redibujar el puzzle mientras se arrastra

    // Dibujar el efecto de la pieza de destino
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
    const targetPiece = getPieceAt(x, y);
    if (targetPiece && targetPiece !== currentPiece) {
      effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)'; // Color verde para la pieza de destino
      effectCtx.lineWidth = 3; // Borde m√°s grueso
      effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.width, targetPiece.height);
    }
  }

  function handleMouseUp(e) {
    if (paused || puzzleEnded || !currentPiece) return;
    effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height); // Limpiar efecto

    const rect = puzzleCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const targetPiece = getPieceAt(mouseX, mouseY);

    if (targetPiece && targetPiece !== currentPiece) {
      swapPieces(currentPiece, targetPiece);
    } else {
      // Si no se solt√≥ sobre otra pieza, regresa la pieza a su posici√≥n original antes del arrastre
      // Nota: Esto es simplificado. En un juego real, la pieza deber√≠a volver a la posici√≥n de la que fue arrastrada.
      // Para este puzzle, las piezas no tienen una posici√≥n "original de arrastre", solo la del array.
      // Si no se solt√≥ sobre otra pieza, la pieza permanece en su √∫ltima posici√≥n al arrastrar.
      // Esto es aceptable para un puzzle simple.
    }
    currentPiece = null; // Liberar la pieza actual
    drawPuzzle(); // Asegurar que todo est√© dibujado correctamente
  }

  function handleTouchStart(e) {
    e.preventDefault(); // Prevenir el scroll
    const touch = e.touches[0];
    handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
  }

  function handleTouchMove(e) {
    e.preventDefault(); // Prevenir el scroll
    const touch = e.touches[0];
    handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
  }

  function handleTouchEnd(e) {
    e.preventDefault(); // Prevenir el scroll
    handleMouseUp({}); // Simular un evento de rat√≥n sin coordenadas, ya que currentPiece se maneja globalmente
  }

  // Event Listeners
  puzzleCanvas.addEventListener('mousedown', handleMouseDown);
  puzzleCanvas.addEventListener('mousemove', handleMouseMove);
  puzzleCanvas.addEventListener('mouseup', handleMouseUp);
  puzzleCanvas.addEventListener('mouseleave', handleMouseUp); // Para soltar fuera del canvas

  puzzleCanvas.addEventListener('touchstart', handleTouchStart);
  puzzleCanvas.addEventListener('touchmove', handleTouchMove);
  puzzleCanvas.addEventListener('touchend', handleTouchEnd);
  puzzleCanvas.addEventListener('touchcancel', handleTouchEnd);

  restartBtn.addEventListener('click', init);
  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    if (paused) {
      pauseBtn.textContent = '‚ñ∂Ô∏è Reanudar';
      clearInterval(timerInterval);
    } else {
      pauseBtn.textContent = '‚è∏Ô∏è Pausar';
      startTime = Date.now() - Math.floor(elapsedTime / 1000) * 1000; // Ajustar startTime
      timerInterval = setInterval(updateTimer, 1000);
    }
  });

  window.addEventListener('resize', resizeCanvas);

  // Inicializar el puzzle al cargar la p√°gina
  // La llamada a init se hace ahora desde image.onload, una vez que la imagen ha cargado.
  // Pero necesitamos una llamada inicial a resizeCanvas para establecer el tama√±o del lienzo
  resizeCanvas(); 
</script>
</body>
</html>
