<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle 8: Plaza de la Virgen</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: 'Press Start 2P', cursive;
            color: #ecf0f1;
            overflow: hidden; /* Evita scroll en dispositivos m√≥viles */
        }
        .puzzle-container {
            text-align: center;
            background-color: #34495e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            max-width: 90vw; /* Ajuste para pantallas peque√±as */
            max-height: 90vh; /* Ajuste para pantallas peque√±as */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #puzzleWrapper {
            position: relative;
            width: clamp(280px, 80vw, 800px); /* Ancho responsivo */
            padding-bottom: 56.25%; /* Ratio 16:9 (o ajusta al ratio de tus im√°genes) */
            height: 0;
            border: 5px solid #333;
            box-sizing: border-box;
            background-color: #222;
            margin-bottom: 20px;
            overflow: hidden;
            display: block; /* Asegura que ocupa su espacio */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Previene scroll y zoom t√°ctil no deseado */
        }
        #puzzleCanvas {
            z-index: 1;
        }
        #effectCanvas {
            z-index: 2;
            pointer-events: none; /* Permite que los eventos de rat√≥n pasen al canvas de abajo */
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            background-color: #e67e22;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em; /* Ajuste para pantallas peque√±as */
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #d35400;
        }
        #timerDisplay {
            font-size: 1em;
            margin-top: 10px;
            background-color: #2c3e50;
            padding: 5px 10px;
            border-radius: 5px;
        }
        #completeMessage {
            font-size: 1.2em;
            color: gold;
            margin-top: 20px;
            display: none;
        }

        /* Media Queries para responsividad */
        @media (max-width: 600px) {
            .puzzle-container {
                padding: 10px;
            }
            button {
                font-size: 0.6em;
                padding: 8px 10px;
            }
            #timerDisplay {
                font-size: 0.8em;
            }
            #completeMessage {
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="puzzle-container">
        <h1>Puzzle: Plaza de la Virgen</h1>
        <div id="puzzleWrapper">
            <canvas id="puzzleCanvas"></canvas>
            <canvas id="effectCanvas"></canvas>
        </div>
        <div class="controls">
            <button id="restartBtn">üîÑ Reiniciar</button>
            <button id="pauseBtn">‚è∏Ô∏è Pausar</button>
        </div>
        <div id="timerDisplay">Tiempo: 00:00</div>
        <div id="completeMessage">¬°Puzzle Completado! üéâ</div>
    </div>

    <script>
    const puzzleCanvas = document.getElementById('puzzleCanvas');
    const ctx = puzzleCanvas.getContext('2d');
    const effectCanvas = document.getElementById('effectCanvas');
    const effectCtx = effectCanvas.getContext('2d');
    
    const image = new Image();
    const imageSrc = "imagenes_puzzles/P8_plaza_de_la_virgen.jpg"; // <--- CAMBIA ESTO PARA CADA PUZZLE

    // Asegura que la imagen se cargue completamente antes de inicializar
    image.onload = () => {
        // Redimensiona los canvases antes de iniciar el puzzle
        resizeCanvas(); 
        init(); 
    };
    image.onerror = () => {
        console.error("Error al cargar la imagen:", imageSrc);
        // Puedes mostrar un mensaje de error al usuario aqu√≠
        alert("No se pudo cargar la imagen del puzzle. Intenta recargar la p√°gina.");
    };
    image.src = imageSrc; // ¬°Inicia la carga de la imagen!

    const restartBtn = document.getElementById('restartBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const completeMsg = document.getElementById('completeMessage');
    const puzzleWrapper = document.getElementById('puzzleWrapper');
    const timerDisplay = document.getElementById('timerDisplay');
    let puzzlePieces = [];
    let cols = 4; // N√∫mero de columnas
    let rows = 3; // N√∫mero de filas
    let pieceWidth, pieceHeight;
    let currentPiece = null;
    let offsetX, offsetY;
    let startTime, timerInterval;
    let paused = false;
    let puzzleEnded = false; 

    function resizeCanvas() {
        // Aseg√∫rate de que el wrapper tenga dimensiones antes de obtenerlas
        const wrapperRect = puzzleWrapper.getBoundingClientRect();
        
        // Ajusta las dimensiones del canvas a las del wrapper
        puzzleCanvas.width = wrapperRect.width;
        puzzleCanvas.height = wrapperRect.height;
        effectCanvas.width = wrapperRect.width;
        effectCanvas.height = wrapperRect.height;

        // Recalcula el tama√±o de las piezas y redibuja si la imagen ya carg√≥
        if (image.complete && image.naturalWidth > 0) {
            pieceWidth = puzzleCanvas.width / cols;
            pieceHeight = puzzleCanvas.height / rows;
            drawPuzzle(); 
        }
    }

    function init() {
        puzzleEnded = false;
        completeMsg.style.display = 'none';
        puzzleWrapper.style.borderColor = '#333';
        paused = false;
        pauseBtn.textContent = '‚è∏Ô∏è Pausar';
        timerDisplay.textContent = 'Tiempo: 00:00';
        clearInterval(timerInterval);

        // Aseg√∫rate de que pieceWidth y pieceHeight se calculen aqu√≠ despu√©s del redimensionado
        // Esto es crucial para que las piezas tengan el tama√±o correcto
        pieceWidth = puzzleCanvas.width / cols;
        pieceHeight = puzzleCanvas.height / rows;

        createPieces();
        shufflePieces();
        drawPuzzle();
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
    }

    function createPieces() {
        puzzlePieces = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                puzzlePieces.push({
                    x: c * pieceWidth,
                    y: r * pieceHeight,
                    originalX: c * pieceWidth,
                    originalY: r * pieceHeight,
                    width: pieceWidth,
                    height: pieceHeight,
                    row: r,
                    col: c,
                    originalRow: r,
                    originalCol: c,
                });
            }
        }
    }

    function shufflePieces() {
        for (let i = puzzlePieces.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [puzzlePieces[i], puzzlePieces[j]] = [puzzlePieces[j], puzzlePieces[i]];
        }
    }

    function drawPuzzle() {
        ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        puzzlePieces.forEach(piece => {
            ctx.drawImage(
                image,
                // Coordenadas de origen en la imagen (para la parte de la imagen)
                piece.originalX * (image.naturalWidth / puzzleCanvas.width), 
                piece.originalY * (image.naturalHeight / puzzleCanvas.height), 
                piece.width * (image.naturalWidth / puzzleCanvas.width), 
                piece.height * (image.naturalHeight / puzzleCanvas.height), 
                // Coordenadas de destino en el canvas (donde se dibujar√° la pieza)
                piece.x, 
                piece.y, 
                piece.width, 
                piece.height 
            );
            ctx.strokeStyle = '#555'; 
            ctx.lineWidth = 1; 
            ctx.strokeRect(piece.x, piece.y, piece.width, piece.height);
        });
    }

    function getPieceAt(x, y) {
        for (let i = puzzlePieces.length - 1; i >= 0; i--) {
            const piece = puzzlePieces[i];
            if (x > piece.x && x < piece.x + piece.width &&
                y > piece.y && y < piece.y + piece.height) {
                return piece;
            }
        }
        return null;
    }

    function swapPieces(p1, p2) {
        [p1.x, p2.x] = [p2.x, p1.x];
        [p1.y, p2.y] = [p2.y, p1.y];
        drawPuzzle();
        if (checkWin()) {
            endPuzzle();
        }
    }

    function checkWin() {
        for (let i = 0; i < puzzlePieces.length; i++) {
            const piece = puzzlePieces[i];
            if (piece.x !== piece.originalX || piece.y !== piece.originalY) {
                return false;
            }
        }
        return true;
    }

    function endPuzzle() {
        puzzleEnded = true;
        clearInterval(timerInterval);
        completeMsg.style.display = 'block';
        puzzleWrapper.style.borderColor = 'gold'; 
    }

    function updateTimer() {
        if (paused || puzzleEnded) return;
        const currentTime = Date.now();
        const elapsedTime = Math.floor((currentTime - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        timerDisplay.textContent = `Tiempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function handleMouseDown(e) {
        if (paused || puzzleEnded) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentPiece = getPieceAt(x, y);
        if (currentPiece) {
            offsetX = x - currentPiece.x;
            offsetY = y - currentPiece.y;
            puzzlePieces = puzzlePieces.filter(p => p !== currentPiece);
            puzzlePieces.push(currentPiece);
            drawPuzzle();
            effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        }
    }

    function handleMouseMove(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        const rect = puzzleCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        currentPiece.x = x - offsetX;
        currentPiece.y = y - offsetY;
        drawPuzzle();

        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);
        const targetPiece = getPieceAt(x, y);
        if (targetPiece && targetPiece !== currentPiece) {
            effectCtx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
            effectCtx.lineWidth = 3;
            effectCtx.strokeRect(targetPiece.x, targetPiece.y, targetPiece.width, targetPiece.height);
        }
    }

    function handleMouseUp(e) {
        if (paused || puzzleEnded || !currentPiece) return;
        effectCtx.clearRect(0, 0, effectCanvas.width, effectCanvas.height);

        const rect = puzzleCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const targetPiece = getPieceAt(mouseX, mouseY);

        if (targetPiece && targetPiece !== currentPiece) {
            swapPieces(currentPiece, targetPiece);
        } 
        currentPiece = null;
        drawPuzzle();
    }

    function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        handleMouseUp({});
    }

    puzzleCanvas.addEventListener('mousedown', handleMouseDown);
    puzzleCanvas.addEventListener('mousemove', handleMouseMove);
    puzzleCanvas.addEventListener('mouseup', handleMouseUp);
    puzzleCanvas.addEventListener('mouseleave', handleMouseUp);

    puzzleCanvas.addEventListener('touchstart', handleTouchStart);
    puzzleCanvas.addEventListener('touchmove', handleTouchMove);
    puzzleCanvas.addEventListener('touchend', handleTouchEnd);
    puzzleCanvas.addEventListener('touchcancel', handleTouchEnd);

    restartBtn.addEventListener('click', init);
    pauseBtn.addEventListener('click', () => {
        paused = !paused;
        if (paused) {
            pauseBtn.textContent = '‚ñ∂Ô∏è Reanudar';
            clearInterval(timerInterval);
        } else {
            pauseBtn.textContent = '‚è∏Ô∏è Pausar';
            // Para ajustar el tiempo al reanudar
            const currentTime = Date.now();
            const currentElapsedTime = Math.floor((currentTime - startTime) / 1000);
            startTime = Date.now() - currentElapsedTime * 1000;
            timerInterval = setInterval(updateTimer, 1000);
        }
    });

    // Escucha el evento de redimensionamiento de la ventana
    window.addEventListener('resize', resizeCanvas);
    // Llama a resizeCanvas inicialmente para establecer el tama√±o correcto
    // Esto se ejecutar√° ANTES de que la imagen cargue, lo cual est√° bien.
    // El 'init' se encarga de re-calcular piezas una vez la imagen est√© lista.
    resizeCanvas(); 
</script>
</body>
</html>
